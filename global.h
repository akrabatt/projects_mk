#include "define.h"

// Буферы для передачи данных с использованием DMA
unsigned char __attribute__((coherent)) buf_tx5[300];
unsigned char __attribute__((coherent)) buf_tx4[300];
unsigned char __attribute__((coherent)) buf_tx3[300];
unsigned char __attribute__((coherent)) buf_tx2[300];
unsigned char __attribute__((coherent)) buf_tx1[300];

// Счетчик миганий
int blink_counter = 0;

// Скорость интерфейсов U1, U2, U3, U4, U5
unsigned int U4_speed;
unsigned int U5_speed;
unsigned int U3_speed;
unsigned int U2_speed;
unsigned int U1_speed;

volatile unsigned int SECOND = 200;  //переменная для таймера 6, отсчитывает 1 секунду

// Задержка между кадрами
unsigned int frame_delay;

// Помощник для сброса
unsigned short help_reset;

// Помощник для загрузки
unsigned short help_load;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
union tag_direct
{
    struct
    {
        union
        {
            struct
            {
                unsigned short sensor1; // данные канала 1
                unsigned short sensor2; // данные канала 2
                unsigned short sensor3; // данные канала 3
                unsigned short sensor4; // данные канала 4
                unsigned short sensor5; // данные канала 5
                unsigned short sensor6; // данные канала 6
                unsigned short sensor7; // данные канала 7
                unsigned short sensor8; // данные канала 8
                float angle_1;          // угол 1
                float angle_2;          // угол 2
                float angle_3;          // угол 3
                float angle_4;          // угол 4
                float angle_5;          // угол 5
                float angle_6;          // угол 6
                float angle_7;          // угол 7
                float angle_8;          // угол 8
                float angle_9;          // угол 9
                float angle_10;         // угол 10
                float angle_11;         // угол 11
                float angle_12;         // угол 12
                unsigned long par1;     // параметр 1
                unsigned long par2;     // параметр 2
                unsigned long par3;     // параметр 3
                unsigned long par4;     // параметр 4
                unsigned long par5;     // параметр 5
                unsigned long par6;     // параметр 6
                unsigned long par7;     // параметр 7
                unsigned long par8;     // параметр 8
                unsigned long par9;     // параметр 9
                unsigned long par10;    // параметр 10

                struct
                {
                    unsigned bit_1 : 1;      // Состояние DBSKT sin1 ch1: 0 - ОК, 1 - НЕОК
                    unsigned bit_2 : 1;      // Состояние DBSKT cos1 ch1: 0 - ОК, 1 - НЕОК
                    unsigned bit_3 : 1;      // Состояние DBSKT sin2 ch2: 0 - ОК, 1 - НЕОК
                    unsigned bit_4 : 1;      // Состояние DBSKT cos2 ch1: 0 - ОК, 1 - НЕОК
                    unsigned bit_5 : 1;     // Состояние датчика DBSKT ch1: 0 - ОК, 1 - НЕОК
                    unsigned bit_6 : 1;     // Состояние датчика DBSKT ch2: 0 - ОК, 1 - НЕОК
                    unsigned bit_7 : 1; // Сопротивление катушки 1: 0 - ОК, 1 - слишком высокое сопротивление
                    unsigned bit_8 : 1;  // Сопротивление катушки 1: 0 - ОК, 1 - слишком низкое сопротивление
                    unsigned bit_9 : 1; // Сопротивление катушки 2: 0 - ОК, 1 - слишком высокое сопротивление
                    unsigned bit_10 : 1;  // Сопротивление катушки 2: 0 - ОК, 1 - слишком низкое сопротивление
                    unsigned bit_11 : 1;       // Ошибка аналогового выхода 1: 0 - ОК, 1 - ошибка
                    unsigned bit_12 : 1;       // Ошибка аналогового выхода 2: 0 - ОК, 1 - ошибка
                    unsigned bit_13 : 1;      // Ошибка аналогового выхода 2: 0 - ОК, 1 - ошибка
                    unsigned : 19;                // Резервные биты
                };
            };
            unsigned short output[54]; // массив для выходных данных
        };

        union
        {
            struct
            {
                float fl_1;              // число с плавающей запятой 1
                float fl_2;              // число с плавающей запятой 2
                float fl_3;              // число с плавающей запятой 3
                float fl_4;              // число с плавающей запятой 4
                float fl_5;              // число с плавающей запятой 5
                float fl_6;              // число с плавающей запятой 6
                float fl_7;              // число с плавающей запятой 7
                unsigned short command1; // команда 1
                unsigned short command2; // команда 2
                unsigned short command3; // команда 3
                unsigned short command4; // команда 4
                unsigned short command5; // команда 5
                unsigned short command6; // команда 6
                unsigned short command7; // команда 7
                unsigned short command8; // команда 8

                struct
                {
                    unsigned command_On : 1;       // Команда ВКЛ! для блока "Semicrone"
                    unsigned command_Off : 1;      // Команда ВЫКЛ! для блока "Semicrone"
                    unsigned command_Istab_On : 1; // Команда ВКЛ! для функции стабилизации тока
                    unsigned command_Integ_ON : 1; // Команда ВКЛ! для включения I-блока в PI-регулятор (функция стабилизации тока)
                    unsigned : 28;                 // Последние 12 бит = байт для значения регулятора Kp (функция стабилизации тока)
                };
            };
            unsigned short input[24]; // массив для входных данных
        };
    };
    unsigned short buf[78];         // буфер
} MB, MB_swap, calibr, calibr_swap; // структуры для модбаса, чтение - 2000 ... 2078, запись - 0 ... 8
/* Эта структура представляет собой объединение (union) данных, которые могут быть использованы для обмена данными через протокол Modbus.
Она содержит различные поля для данных с датчиков (sensor1 - sensor8), углов (angle_1 - angle_12), параметров (par1 - par10), а также команд
(command1 - command8). Кроме того, она содержит битовую структуру (tag_mb_statusBITS), представляющую различные статусы и команды для управления
блоками. */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct tag_usart
{
    unsigned char out_buffer[OUT_SIZE]; // Массив буфера для исходящих данных (отправляемые данные).
    unsigned char in_buffer[IN_SIZE];   // Массив буфера для входящих данных (принимаемые данные).
    unsigned short out_buffer_count;    // Счетчик числа байт в буфере исходящих данных.
    unsigned short in_buffer_count;     // Счетчик числа байт в буфере входящих данных.
    unsigned short in_buffer_count2;    // Дополнительный счетчик числа байт в буфере входящих данных (второй счетчик).
    unsigned short number_send;         // Количество байт для отправки.
    unsigned short port_type;           // Тип порта.
    unsigned short mbm_status;          // Статус MODBUS.
    unsigned short mbm_err;             // Ошибка MODBUS.
    unsigned short hl_err;              // Ошибка высокого уровня.
    unsigned short mbm_status_hl;       // Статус MODBUS высокого уровня.
    unsigned short mbm_status_05;       // Статус MODBUS 05.
    unsigned short repeat_05;           // Повтор MODBUS 05.
    unsigned short repeat_05_;          // Другой повтор MODBUS 05.
    unsigned short mbm_timeout_counter;         // Тайм-аут счетчик MODBUS. //
    unsigned short answer_count;        //

    struct tag_mb_statusBITS
    {
        unsigned modb_mode : 1;        // 1 бит для режима MODBUS
        unsigned term_mode : 1;        // 1 бит для режима терминала
        unsigned modb_received : 1;    // Флаг получения MODBUS
        unsigned modb_transmited : 1;  // Флаг передачи MODBUS
        unsigned modb_receiving : 1;   // Флаг приема MODBUS
        unsigned modb_transmiting : 1; // Флаг отправки MODBUS
        unsigned tx_mode : 1;          // Режим передачи (USART TX mode)
        unsigned tx_data_rdy : 1;      // Готовность данных к передаче
        unsigned master_error : 1;     // Ошибка мастера
        unsigned bussy1 : 1;           // Резервное поле
        unsigned bussy2 : 1;           // Резервное поле
        unsigned last_byte : 1;        // Флаг последнего байта
        unsigned byte_missing : 1;     // Отсутствие байта
        unsigned coll_1 : 1;           // Коллизия 1
        unsigned coll_2 : 1;           // Коллизия 2
        unsigned coll_3 : 1;           // Коллизия 3
        unsigned tx_start : 1;         // Начало передачи
        unsigned master_start : 1;     // Начало мастера
        unsigned master_timeout_flag : 1;   // флаг ошибки тайм-аута
        unsigned tm_on : 1;            // Включение таймера
        unsigned device_error : 1;     // Ошибка устройства
        unsigned crc_error : 1;        // Ошибка CRC
        unsigned : 10;                 // Резервные биты (19-32)
    } mb_status;
} usart1, usart2, usart3, usart4, usart5;
/* Эта структура tag_usart служит для управления и мониторинга передачи данных через интерфейс USART, а также для управления операциями,
связанными с протоколом MODBUS. Она используется для хранения и обработки исходящих и входящих данных, контроля состояния передачи данных,
отслеживания ошибок и управления различными аспектами обмена данными.
Конкретные поля и битовые структуры внутри этой структуры обеспечивают различные функции, такие как контроль состояния передачи данных (например,
счетчики буфера, статусы MODBUS), отслеживание ошибок (ошибки MODBUS, ошибки высокого уровня) и управление режимами передачи данных (например, режимы
MODBUS и терминала). Таким образом, эта структура играет ключевую роль в организации и контроле обмена данными через USART, а также в обеспечении
надежной и эффективной работы протокола MODBUS в системе. */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct tag_timers_BITS
{
    unsigned bit_1 : 1;   // Первый бит (1)
    unsigned bit_2 : 1;   // Второй бит (2)
    unsigned bit_3 : 1;   // Третий бит (3)
    unsigned bit_4 : 1;   // Четвертый бит (4)
    unsigned bit_5 : 1;   // Пятый бит (5)
    unsigned ch_1 : 1;    // Первый канал (6)
    unsigned ch_2 : 1;    // Второй канал (7)
    unsigned ch_3 : 1;    // Третий канал (8)
    unsigned t_del_1 : 1; // Задержка времени 1 (9)
    unsigned t_del_2 : 1; // Задержка времени 2 (10)
    unsigned t_del_3 : 1; // Задержка времени 3 (11)
    unsigned t_del_4 : 1; // Задержка времени 4 (12)
    unsigned t_del_5 : 1; // Задержка времени 5 (13)
    unsigned t_del_6 : 1; // Задержка времени 6 (14)
    unsigned t_del_7 : 1; // Задержка времени 7 (15)
    unsigned t_del_8 : 1; // Задержка времени 8 (16)
} timer9_bits;            // Определение структуры с именем tag_timers_BITS и создание переменной timer9_bits

// Каждое поле данной структуры представляет собой отдельный бит, используемый для управления таймерами и каналами.
// Номер бита указан в комментарии справа от объявления.
// Эта структура представляет набор флаговых переменных, которые могут быть использованы для управления различными таймерами и каналами.
// Переменная timer9_bits используется для доступа к этой структуре из других частей программы.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Объявление объединения tag_Modbus
union tag_Modbus
{
    // Вложенная структура для хранения различных параметров Modbus
    struct
    {
        // Вложенное объединение для хранения битовых флагов
        union
        {
            // Вложенная структура для управления битовыми флагами
            struct
            {
                unsigned flap_On : 1;           // Флаг открытия заслонки
                unsigned start : 1;             // Флаг старта двигателя
                unsigned ignit_allow : 1;       // Разрешение на зажигание
                unsigned CV_dir_ctrl : 1;       // Управление направлением клапана топлива
                unsigned PWM_dir_ctrl : 1;      // Управление направлением ШИМ
                unsigned ign_ctrl : 1;          // Управление зажиганием
                unsigned unlock : 1;            // Флаг разблокировки
                unsigned AO : 1;                // Флаг аналогового выхода
                unsigned clr_err_cnt : 1;       // Очистка счетчика ошибок
                unsigned stop : 1;              // Флаг остановки
                unsigned press_mode_int : 1;    // Внутренний режим давления
                unsigned press_mode_analog : 1; // Аналоговый режим давления
                unsigned deep_on : 1;           // Флаг глубокого режима
                unsigned NO : 1;                // Зарезервированный бит
                unsigned stop_pid_on : 1;       // Включение PID при остановке
                unsigned stop_pid_off : 1;      // Отключение PID при остановке
                unsigned forced_pid_on : 1;     // Принудительное включение PID
                unsigned forced_pid_off : 1;    // Принудительное отключение PID
                unsigned : 14;                  // Зарезервированные биты
            } bits;                             // Конец вложенной структуры bits

            unsigned long cmd1; // Команда 1 (4 байта)
        }; // Конец вложенного объединения

        unsigned short num_check_cyl; // Номер проверяемого цилиндра
        unsigned short cyl_mask;      // Маска цилиндра
        float RPM_set;                // Установка оборотов двигателя
        float CV_dir_set;             // Установка направления клапана топлива
        float work_status;            // Статус работы БУД
        float RPM11;                  // Обороты, измеренные через синхро 11-зубчатый канал
        float RPM40;                  // Обороты, измеренные через обороты 40-зубчатый канал
        float CV_set;                 // Установка клапана топлива
        float CV_pos;                 // Фактическое положение клапана топлива
        float CV_current;             // Фактический ток клапана
        float actual_UOZ;             // Фактический угол зажигания
        unsigned short AO_reason;     // Причина аналогового выхода
        unsigned short AO_cyl_num;    // Номер цилиндра для аналогового выхода
        unsigned short ADC_CV_pos;    // АЦП клапана топлива
        unsigned short ADC_CV_curr;   // АЦП тока клапана
        unsigned short pulses_11;     // Импульсы синхро 11
        unsigned short pulses_40;     // Импульсы синхро 40
        float err_rpm;                // Ошибка оборотов

        // Вложенное объединение для хранения дополнительных статусов
        union
        {
            // Вложенная структура для управления дополнительными статусами
            struct
            {
                unsigned CV_locked : 1;        // Заблокирован клапан топлива
                unsigned press_via_analog : 1; // Управление давлением через аналог
                unsigned CV_magnet_brake : 1;  // Магнитный тормоз клапана
                unsigned CV_sensor_err : 1;    // Ошибка датчика клапана
                unsigned deep_mode : 1;        // Глубокий режим
                unsigned Protect_unswitch : 1; // Защита от непреднамеренного выключения
                unsigned DI1_ctrl : 1;         // Управление DI1
                unsigned CONTROL1 : 1;         // Контроль 1
                unsigned CONTROL2 : 1;         // Контроль 2
                unsigned CONTROL3 : 1;         // Контроль 3
                unsigned CONTROL4 : 1;         // Контроль 4
                unsigned s12 : 1;              // Зарезервированный бит
                unsigned deep_is_on : 1;       // Глубокий режим включен
                unsigned stop_pid : 1;         // Остановить PID
                unsigned miss_sync : 1;        // Пропущен синхро
                unsigned miss_rpm : 1;         // Пропущена ошибка RPM
                unsigned forced_pid : 1;       // Принудительный PID
                unsigned : 15;                 // Зарезервированные биты
            } status_bits;                     // Конец вложенной структуры status_bits

            unsigned long statuses; // Статусы (4 байта)
        }; // Конец вложенного объединения

        float ign_err_num1; // Ошибка зажигания №1
        float ign_err_num2; // Ошибка зажигания №2
    } Modbus_data;          // Конец структуры Modbus_data
    unsigned short buf[82]; // Буфер данных (164 байта)

} Modbus, Modbus_sw; // Конец объединения tag_Modbus, а также объявление двух переменных: Modbus и Modbus_sw

// MB_READ_ MB_WRITE_ 0 ... 80 - адресация для чтения и записи данных Modbus
/* Это объединение tag_Modbus используется для хранения различных параметров и статусов Modbus, а также для работы с буфером данных.
Внутри структуры содержатся различные поля для хранения информации о состоянии системы, управлении процессами и передаче данных. Каждое поле
имеет свой тип данных и свою семантику использования. Буфер данных используется для хранения информации, которая может быть передана по протоколу
Modbus. */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
union tag_MB_diag
{
    // Вложенная структура для хранения диагностических данных
    struct
    {
        unsigned short break_low[10];  // Счетчик событий обрыва низковольтного провода для каждого из 10 цилиндров
        unsigned short short_low[10];  // Счетчик событий короткого замыкания низковольтного провода для каждого из 10 цилиндров
        unsigned short break_high[10]; // Счетчик событий обрыва высоковольтного провода для каждого из 10 цилиндров
        float discharge_hold[10];      // Мгновенное время разряда, зафиксированное для 10 цилиндров
        float discharge_middle[10];    // Среднее время разряда для 10 цилиндров
    } data_struct;                     // Конец вложенной структуры data_struct

    // Массив слов для хранения диагностических данных
    unsigned short buf[70]; // Массив буфера данных
} MB_diag, MB_diag_sw;      // Экземпляры объединения
/* Это объединение tag_MB_diag также определяет структуру для хранения диагностических данных системы. Вложенная структура
data_struct содержит различные диагностические параметры для каждого из 10 цилиндров двигателя. Кроме того, массив buf используется
для хранения этих параметров в виде массива слов. Объединение позволяет эффективно использовать память, обеспечивая доступ к диагностическим
данным как структуре и как массиву одновременно. */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Объявление объединения tag_diag
union tag_diag
{
    // Вложенная структура для хранения диагностических данных
    struct
    {
        unsigned short break_low[CYLINDERS_NUM];  // Счетчик событий обрыва низковольтного провода для каждого из 10 цилиндров
        unsigned short short_low[CYLINDERS_NUM];  // Счетчик событий короткого замыкания низковольтного провода для каждого из 10 цилиндров
        unsigned short break_high[CYLINDERS_NUM]; // Счетчик событий обрыва высоковольтного провода для каждого из 10 цилиндров
        float discharge_hold[CYLINDERS_NUM];      // Мгновенное время разряда, зафиксированное для 10 цилиндров
        float charge_hold[CYLINDERS_NUM];         // Среднее время разряда для 10 цилиндров
    } data_struct;                                // Конец вложенной структуры data_struct

    // Массив слов для хранения диагностических данных
    unsigned short buf[112]; // Массив буфера данных
} MB_diagn, MB_diagn_sw;     // Экземпляры объединения
/* Это объединение tag_diag определяет структуру для хранения диагностических данных системы. Вложенная структура data_struct содержит
различные диагностические параметры для каждого из 10 цилиндров двигателя. Кроме того, массив buf используется для хранения этих
параметров в виде массива слов. Объединение позволяет эффективно использовать память, обеспечивая доступ к диагностическим данным как
структуре и как массиву одновременно. */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Объявление объединения tag_MB_conf
union tag_MB_conf
{
    // Вложенная структура для хранения конфигурационных параметров
    struct
    {
        float max_RPM;                      // Максимальная скорость вращения двигателя для аварийной остановки
        float min_RPM;                      // Минимальная скорость вращения двигателя для аварийной остановки
        float UOZ_high;                     // Номинальная скорость вращения двигателя для УОЗ
        float UOZ_low;                      // Низкая скорость вращения двигателя для УОЗ
        float UOZ_global_shift;             // Основное корректировочное значение УОЗ для всех цилиндров
        float UOZ_RPM_max;                  // Скорость двигателя, при которой УОЗ становится UOZ_high
        float UOZ_RPM_min;                  // Скорость двигателя, при которой УОЗ становится UOZ_low
        float discharge_sc_low;             // Время разряда для обнаружения низкого напряжения на проводе SC
        float discharge_br_high;            // Время разряда для обнаружения высокого напряжения на проводе высокого напряжения
        float constructive_UOZ;             // Конструктивный угол точки синхронизации и точки зажигания (18 градусов)
        float CV_start_val;                 // Начальное значение открытия клапана при запуске двигателя
        float CV_start_spd;                 // Скорость открытия клапана до начального значения
        float CV_open_spd;                  // Скорость открытия клапана при запуске двигателя до РМП ПИД
        float PID_spd;                      // РМП, при которых начинается работа ПИ-регулятора двигателя
        float Ignit_spd;                    // РМП, при которых возможен запуск зажигания
        float CV_pos_min;                   // Минимальный код АЦП клапана
        float CV_pos_max;                   // Максимальный код АЦП клапана
        float CV_curr_min;                  // Минимальный код АЦП тока клапана
        float CV_curr_max;                  // Максимальный код АЦП тока клапана
        float CV_curr_scale;                // Масштабирование тока клапана между минимальными и максимальными кодами
        float CV_KP;                        // Пропорциональный коэффициент ПИ-регулятора клапана
        float CV_KD;                        // Дифференциальный коэффициент ПИ-регулятора клапана
        float CV_KI;                        // Интегральный коэффициент ПИ-регулятора клапана
        float NUM_ERR_AO;                   // Резерв
        float KP_mpid;                      // Резерв
        float KI_mpid;                      // Резерв
        float KD_mpid;                      // Резерв
        float Timer_to_PID;                 // Резерв
        float PID_deadband;                 // Резерв
        float KP_res_limit;                 // Резерв
        float CV_check_level;               // Резерв
        float UOZ_shift_ind[CYLINDERS_NUM]; // Массив сдвига УОЗ для каждого цилиндра
    } data_struct;                          // Конец вложенной структуры data_struct

    // Массив слов для хранения конфигурационных данных
    unsigned short buf[90]; // Массив буфера данных
} MB_conf, MB_sw_conf;      // Экземпляры объединения
/* Это объединение tag_MB_conf определяет структуру для хранения различных конфигурационных параметров системы. Оно содержит
вложенную структуру data_struct, которая описывает каждый конфигурационный параметр. Кроме того, массив buf используется для
хранения этих параметров в виде массива слов. Объединение позволяет эффективно использовать память, обеспечивая доступ к конфигурационным
данным как структуре и как массиву одновременно. */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Описание структуры MOPS (Модуль Охранной Пожарной Сигнализации)
// Структура, содержащая различную информацию о состоянии зон MOPS
typedef union tag_MOPS
{

    struct
    {

        union
        {
            // Внутренние статусы зон MOPS
            struct
            {
                unsigned short info[3];                    // Информация о зонах
                unsigned short status[num_zone_mops];      // Состояние каждой зоны
                unsigned short hold_status[num_zone_mops]; // запомненное состояние каждой зоны
                unsigned short current[num_zone_mops + 1]; // Текущее состояние каждой зоны
            };
            // Чтение внутренних статусов зон MOPS
            unsigned short read[num_zone_mops * 3 + 4]; // Чтение информации о состоянии зон MOPS
        };

        union
        {
            // Команды для зон MOPS
            struct
            {
                unsigned short command[num_zone_mops]; // Команда для каждой зоны
                unsigned short type[num_zone_mops];    // Тип каждой зоны
                unsigned short limit1[num_zone_mops];  // Предел 1 для каждой зоны
                unsigned short limit2[num_zone_mops];  // Предел 2 для каждой зоны
                unsigned short limit3[num_zone_mops];  // Предел 3 для каждой зоны
                unsigned short limit4[num_zone_mops];  // Предел 4 для каждой зоны
                unsigned short timer1[num_zone_mops];  // Таймер 1 для каждой зоны
                unsigned short timer2[num_zone_mops];  // Таймер 2 для каждой зоны
                unsigned short timer3[num_zone_mops];  // Таймер 3 для каждой зоны
                unsigned short timer4[num_zone_mops];  // Таймер 4 для каждой зоны
            };
            // Запись команд для зон MOPS
            unsigned short write[num_zone_mops * 10]; // Запись команд для зон MOPS
        };
    };
    // Область памяти для хранения информации о зонах MOPS
    unsigned short main_area[num_zone_mops * 13 + 4];
} MOPS, MOPS_swap; // Псевдонимы для удобства использования
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
unsigned short DINPUT1;
unsigned short DINPUT2;
unsigned short DINPUT3;
