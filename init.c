#include "extern.h"

extern __inline__ unsigned int __attribute__((always_inline)) _VirtToPhys(const void *p)
{
    // Функция _VirtToPhys используется для преобразования виртуального адреса в физический адрес.
    // Возвращает физический адрес, который является смещением на 0x40000000 от виртуального адреса,
    // если виртуальный адрес неотрицателен, иначе возвращает младшие 29 бит виртуального адреса.
    return (int)p < 0 ? ((int)p & 0x1fffffffL) : (unsigned int)((unsigned char *)p + 0x40000000L);
}

// Настройки Ethernet

#pragma config FMIIEN = OFF  // Включение/выключение интерфейса Ethernet (выключен)
#pragma config FETHIO = ON   // Выбор выводов для Ethernet (стандартные выводы)
#pragma config PGL1WAY = ON  // Разрешение однократной настройки группы разрешений (разрешена однократная настройка)
#pragma config PMDL1WAY = ON // Разрешение однократной настройки модуля периферии (разрешена однократная настройка)
#pragma config IOL1WAY = OFF // Разрешение однократной настройки выбора выводов (разрешена многократная настройка)
#pragma config FUSBIDIO = ON // Выбор модулем USB идентификатора (идентификатор USB контролируется модулем USB)

// DEVCFG2
/* DEVCFG2 - это макроопределение, которое используется для установки конфигурации DEVCFG2 (Device Configuration 2)
микроконтроллера PIC32MZ1024EFH100. DEVCFG2 определяет настройки такие как делитель входного сигнала системного PLL (FPLLIDIV),
диапазон входного сигнала системного PLL (FPLLRNG), источник тактового сигнала системного PLL (FPLLICLK), множитель системного
PLL (FPLLMULT), делитель выходного сигнала системного PLL (FPLLODIV) и частота входного сигнала USB PLL (UPLLFSEL). Эти настройки
позволяют настроить работу системного и USB PLL для достижения требуемой частоты ядра и периферийных устройств
микроконтроллера. */
#pragma config FPLLIDIV = DIV_1         // Делитель входного сигнала для системной PLL (делитель на 3)
#pragma config FPLLRNG = RANGE_8_16_MHZ // Диапазон входного сигнала для системной PLL (5-10 МГц)
#pragma config FPLLICLK = PLL_POSC      // Источник тактового сигнала для системной PLL (внешний осциллятор)
#pragma config FPLLMULT = MUL_27        // Множитель системной PLL (увеличение в 50 раз)
#pragma config FPLLODIV = DIV_2         // Делитель выходного сигнала системной PLL (делитель на 2)
#pragma config UPLLFSEL = FREQ_24MHZ    // Частота входного сигнала для USB PLL (24 МГц)

// DEVCFG1
/* DEVCFG1 - это макроопределение, используемое для установки конфигурации DEVCFG1 (Device Configuration 1)
микроконтроллера PIC32MZ1024EFH100. DEVCFG1 определяет настройки, такие как выбор источника тактового сигнала (FNOSC),
интервал счета окна DMT (DMTINTV), включение внутреннего/внешнего переключения (IESO), конфигурация основного
генератора (POSCMOD), включение осциллятора для отладки (OSCIOFNC), выбор внутреннего мультиплексора FSCM и другие.
Эти настройки позволяют настраивать основные параметры тактовой подсистемы микроконтроллера, включая выбор осциллятора,
настройки сторожевого таймера и другие параметры работы ядра. */
#pragma config FNOSC = SPLL          // Выбор источника тактового сигнала (системная PLL)
#pragma config DMTINTV = WIN_127_128 // Интервал счета DMT (127/128 от значения счетчика)
#pragma config FSOSCEN = OFF         // Включение/выключение вторичного осциллятора (выключен)
#pragma config IESO = ON             // Включение/выключение автопереключения источника тактового сигнала (включено)
#pragma config POSCMOD = EC          // Режим настройки осциллятора (внешний кварц)
#pragma config OSCIOFNC = OFF        // Настройка вывода CLKO (выключено)
#pragma config FCKSM = CSECME        // Настройка переключения тактового сигнала и монитора (переключение тактового сигнала и монитор включены)
#pragma config WDTPS = PS1048576     // Предделитель сторожевого таймера (1:1048576)
#pragma config WDTSPGM = STOP        // Остановка сторожевого таймера во время программирования Flash (сторожевой таймер останавливается во время программирования Flash)
#pragma config WINDIS = NORMAL       // Режим окошечного сторожевого таймера (нормальный)
#pragma config FWDTEN = OFF          // Включение/выключение сторожевого таймера (выключено)
#pragma config FWDTWINSZ = WINSZ_25  // Размер окошечного сторожевого таймера (25%)
#pragma config DMTCNT = DMT31        // Выбор значения счетчика Deadman Timer (2^31)
#pragma config FDMTEN = OFF          // Включение/выключение Deadman Timer (выключено)

// DEVCFG0
/* DEVCFG0 - это макроопределение, используемое для установки конфигурации DEVCFG0 (Device Configuration 0) микроконтроллера
PIC32MZ1024EFH100. DEVCFG0 определяет настройки, такие как разрешение отладчика на фоновый режим (DEBUG), включение JTAG
(JTAGEN), выбор канала связи ICE/ICD (ICESEL), разрешение трассировки (TRCEN), выбор ISA загрузочного кода (BOOTISA),
конфигурацию ECC для Flash-памяти (FECCCON), режим сна Flash (FSLEEP), доступ к режиму отладки для CPU (DBGPER), программный
сброс (SMCLR), усиление вторичного осциллятора (SOSCGAIN), включение ускорения вторичного осциллятора (SOSCBOOST), усиление
основного осциллятора (POSCGAIN), включение ускорения основного осциллятора (POSCBOOST), настройка EJTAG (EJTAGBEN), а также
кодовая защита (CP). Эти настройки определяют различные аспекты работы микроконтроллера, такие как настройки отладки, режимы сна,
конфигурация интерфейсов и другие параметры. */
#pragma config DEBUG = OFF            // Включение/выключение отладчика (выключен)
#pragma config JTAGEN = OFF           // Включение/выключение JTAG (выключен)
#pragma config ICESEL = ICS_PGx1      // Выбор канала общения ICE/ICD (PGEC2/PGED2)
#pragma config TRCEN = ON             // Включение/выключение трассировки (включена)
#pragma config BOOTISA = MIPS32       // Выбор ISA для загрузки (MIPS32)
#pragma config FECCCON = OFF_UNLOCKED // Конфигурация динамической ECC для Flash (ECC и динамическая ECC отключены)
#pragma config FSLEEP = OFF           // Режим сна для Flash (Flash от//ключается во время сна)
#pragma config DBGPER = ALLOW_PG2     // Разрешение доступа отладочного режима к CPU (разрешен доступ к Permission Group 2)
#pragma config SMCLR = MCLR_NORM      // Включение/выключение мягкого сброса (нормальный режим сброса)
#pragma config SOSCGAIN = GAIN_2X     // Настройка усиления вторичного осциллятора (усиление в 2 раза)
#pragma config SOSCBOOST = ON         // Включение/выключение ускорения старта вторичного осциллятора (ускорение старта осциллятора)
#pragma config POSCGAIN = GAIN_2X     // Настройка усиления первичного осциллятора (усиление в 2 раза)
#pragma config POSCBOOST = ON         // Включение/выключение ускорения старта первичного осциллятора (ускорение старта осциллятора)
#pragma config EJTAGBEN = NORMAL      // Загрузка EJTAG (нормальное EJTAG-функциональность)

// DEVCP0
/* DEVCP0 - это макроопределение, используемое для установки конфигурации DEVCP0 (Device Code Protection 0)
микроконтроллера PIC32MZ1024EFH100. DEVCP0 определяет настройки защиты кода, такие как защита кода (CP),
которая может быть включена или выключена. Когда защита кода включена (CP = ON), это означает, что защита
программного кода активна, что делает невозможным чтение и/или запись программного кода в микроконтроллер без
специальных разрешений или безопасных процедур. */
#pragma config CP = OFF // Защита кода (защита отключена)

/*** Ports System Service Configuration ***/

// Настройки порта A
#define SYS_PORT_A_ANSEL 0x0600 // Настройка регистра ANSEL для порта A
#define SYS_PORT_A_TRIS 0xc6e3  // Настройка регистра TRIS для порта A
#define SYS_PORT_A_LAT 0x0      // Настройка регистра LAT для порта A
#define SYS_PORT_A_ODC 0x0      // Настройка регистра ODC для порта A
#define SYS_PORT_A_CNPU 0x0     // Настройка регистра CNPU для порта A
#define SYS_PORT_A_CNPD 0x0     // Настройка регистра CNPD для порта A
#define SYS_PORT_A_CNEN 0x0     // Настройка регистра CNEN для порта A

// Настройки порта B
#define SYS_PORT_B_ANSEL 0x8000 // Настройка регистра ANSEL для порта B
#define SYS_PORT_B_TRIS 0xe6ff  // Настройка регистра TRIS для порта B
#define SYS_PORT_B_LAT 0x8000   // Настройка регистра LAT для порта B
#define SYS_PORT_B_ODC 0x0      // Настройка регистра ODC для порта B
#define SYS_PORT_B_CNPU 0x0     // Настройка регистра CNPU для порта B
#define SYS_PORT_B_CNPD 0x0     // Настройка регистра CNPD для порта B
#define SYS_PORT_B_CNEN 0x0     // Настройка регистра CNEN для порта B

// Настройки порта C
#define SYS_PORT_C_ANSEL 0x0   // Настройка регистра ANSEL для порта C
#define SYS_PORT_C_TRIS 0xb01e // Настройка регистра TRIS для порта C
#define SYS_PORT_C_LAT 0x0     // Настройка регистра LAT для порта C
#define SYS_PORT_C_ODC 0x0     // Настройка регистра ODC для порта C
#define SYS_PORT_C_CNPU 0x0    // Настройка регистра CNPU для порта C
#define SYS_PORT_C_CNPD 0x0    // Настройка регистра CNPD для порта C
#define SYS_PORT_C_CNEN 0x0    // Настройка регистра CNEN для порта C

// Настройки порта D
#define SYS_PORT_D_ANSEL 0x0 // Настройка регистра ANSEL для порта D
#define SYS_PORT_D_TRIS 0x14 // Настройка регистра TRIS для порта D
#define SYS_PORT_D_LAT 0x0   // Настройка регистра LAT для порта D
#define SYS_PORT_D_ODC 0x0   // Настройка регистра ODC для порта D
#define SYS_PORT_D_CNPU 0x0  // Настройка регистра CNPU для порта D
#define SYS_PORT_D_CNPD 0x0  // Настройка регистра CNPD для порта D
#define SYS_PORT_D_CNEN 0x0  // Настройка регистра CNEN для порта D

// Настройки порта E
#define SYS_PORT_E_ANSEL 0x0  // Настройка регистра ANSEL для порта E
#define SYS_PORT_E_TRIS 0x3e0 // Настройка регистра TRIS для порта E
#define SYS_PORT_E_LAT 0x10   // Настройка регистра LAT для порта E
#define SYS_PORT_E_ODC 0x0    // Настройка регистра ODC для порта E
#define SYS_PORT_E_CNPU 0x0   // Настройка регистра CNPU для порта E
#define SYS_PORT_E_CNPD 0x0   // Настройка регистра CNPD для порта E
#define SYS_PORT_E_CNEN 0x0   // Настройка регистра CNEN для порта E

// Настройки порта F
#define SYS_PORT_F_ANSEL 0x0   // Настройка регистра ANSEL для порта F
#define SYS_PORT_F_TRIS 0x113b // Настройка регистра TRIS для порта F
#define SYS_PORT_F_LAT 0x0     // Настройка регистра LAT для порта F
#define SYS_PORT_F_ODC 0x0     // Настройка регистра ODC для порта F
#define SYS_PORT_F_CNPU 0x0    // Настройка регистра CNPU для порта F
#define SYS_PORT_F_CNPD 0x0    // Настройка регистра CNPD для порта F
#define SYS_PORT_F_CNEN 0x0    // Настройка регистра CNEN для порта F

// Настройки порта G
#define SYS_PORT_G_ANSEL 0x0   // Настройка регистра ANSEL для порта G
#define SYS_PORT_G_TRIS 0x8343 // Настройка регистра TRIS для порта G
#define SYS_PORT_G_LAT 0x0     // Настройка регистра LAT для порта G
#define SYS_PORT_G_ODC 0x0     // Настройка регистра ODC для порта G
#define SYS_PORT_G_CNPU 0x0    // Настройка регистра CNPU для порта G
#define SYS_PORT_G_CNPD 0x0    // Настройка регистра CNPD для порта G
#define SYS_PORT_G_CNEN 0x0    // Настройка регистра CNEN для порта G

void port_init(void)
{
    // Настройка порта A
    TRISA = SYS_PORT_A_TRIS;   // Установка направления порта A в соответствии с предопределенными значениями
    ANSELA = SYS_PORT_A_ANSEL; // Настройка аналоговых входов порта A в соответствии с предопределенными значениями

    // Настройка порта B
    TRISB = SYS_PORT_B_TRIS;   // Установка направления порта B в соответствии с предопределенными значениями
    ANSELB = SYS_PORT_B_ANSEL; // Настройка аналоговых входов порта B в соответствии с предопределенными значениями

    // Настройка порта C
    TRISC = SYS_PORT_C_TRIS;   // Установка направления порта C в соответствии с предопределенными значениями
    ANSELC = SYS_PORT_C_ANSEL; // Настройка аналоговых входов порта C в соответствии с предопределенными значениями

    // Настройка порта D
    TRISD = SYS_PORT_D_TRIS; // Установка направления порта D в соответствии с предопределенными значениями
    ANSELD = 0;              // Отключение аналоговых входов порта D
    LATD = SYS_PORT_D_LAT;   // Установка состояния порта D в соответствии с предопределенными значениями

    // Настройка порта E
    TRISE = SYS_PORT_E_TRIS;   // Установка направления порта E в соответствии с предопределенными значениями
    ANSELE = SYS_PORT_E_ANSEL; // Настройка аналоговых входов порта E в соответствии с предопределенными значениями

    // Настройка порта F
    TRISF = SYS_PORT_F_TRIS;   // Установка направления порта F в соответствии с предопределенными значениями
    ANSELF = SYS_PORT_F_ANSEL; // Настройка аналоговых входов порта F в соответствии с предопределенными значениями

    // Настройка порта G
    TRISG = SYS_PORT_G_TRIS;   // Установка направления порта G в соответствии с предопределенными значениями
    ANSELG = SYS_PORT_G_ANSEL; // Настройка аналоговых входов порта G в соответствии с предопределенными значениями

    // Дополнительная настройка некоторых специфических портов и их функций
    TRISBbits.TRISB15 = 0; // Установка направления порта B, 15-й ножки, в качестве выхода для управления 3-м UART
    TRISDbits.TRISD1 = 0;  // Установка направления порта D, 1-й ножки, в качестве выхода для управления 1-м UART

    // Назначение функций для приема данных UART на соответствующих портах
    U1RXRbits.U1RXR = 0b0000; // Подключение приемника UART1 к порту RPD2
    U2RXRbits.U2RXR = 0b0100; // Подключение приемника UART2 к порту RPD4
    U3RXRbits.U3RXR = 0b0111; // Подключение приемника UART3 к порту RPC13
    U4RXRbits.U4RXR = 0b0010; // Подключение приемника UART4 к порту RPB14
    U5RXRbits.U5RXR = 0b1101; // Подключение приемника UART5 к порту RPA14

    // Назначение функций для передачи данных UART на соответствующих портах
    RPD3Rbits.RPD3R = 0b0001;   // Подключение передатчика UART1 к порту RPD3
    RPD5Rbits.RPD5R = 0b0010;   // Подключение передатчика UART2 к порту RPD5
    RPC14Rbits.RPC14R = 0b0001; // Подключение передатчика UART3 к порту RPC14
    RPF12Rbits.RPF12R = 0b0010; // Подключение передатчика UART4 к порту RPF12
    RPA15Rbits.RPA15R = 0b0011; // Подключение передатчика UART5 к порту RPA15

    // Назначение функции SPI для порта B, 10-й ножки
    RPB10Rbits.RPB10R = 0b1001; // Подключение SPI к порту RPB10
}

void tmr_1_init(unsigned short T_delay, unsigned short TMR_IE, unsigned short TMR_ON)
{
    T1CONbits.TON = 0;
    TMR1 = 0x0000;
    PR1 = T_delay; //
    IEC0bits.T1IE = TMR_IE;
    IPC1bits.T1IP = 0b10; // priority = 2
    T1CONbits.TCKPS = 0;  // T1 prescaler 1:8
    T1CONbits.TON = TMR_ON;
}

void tmr_2_init(unsigned short T_delay, unsigned short TMR_IE, unsigned short TMR_ON)
{
    T2CONbits.TON = 0;
    TMR2 = 0x0000;
    PR2 = T_delay; //
    IEC0bits.T2IE = TMR_IE;
    IPC2bits.T2IP = 0b10; // priority = 2
    T2CONbits.TCKPS = 0;  // T1 prescaler 1:8
    T2CONbits.TON = TMR_ON;
}

void tmr_5_init(unsigned short T_delay, unsigned short TMR_IE, unsigned short TMR_ON)
{
    T5CONbits.TON = 0;
    TMR5 = 0x0000;
    PR5 = T_delay; //
    IEC0bits.T5IE = TMR_IE;
    IPC6bits.T5IP = 0b10; // priority = 2
    T5CONbits.TCKPS = 0;  // T1 prescaler 1:8
    T5CONbits.TON = TMR_ON;
}

void tmr_9_init(unsigned short T9_delay, unsigned short TMR9_IE, unsigned short TMR9_ON)
{
    T9CONbits.TON = 0;
    TMR9 = 0x0000;
    PR9 = T9_delay; //
    IEC1bits.T9IE = TMR9_IE;
    IPC10bits.T9IP = 0b10;  // priority = 2
    T9CONbits.TCKPS = 0b11; // T1 prescaler 1:8
    T9CONbits.TON = TMR9_ON;
}

void tmr_6_init(unsigned short T_delay, unsigned short TMR_IE, unsigned short TMR_ON)
{
    T6CONbits.TON = 0;
    TMR6 = 0x0000;
    PR6 = T_delay; //
    IEC0bits.T6IE = TMR_IE;
    IPC7bits.T6IP = 0b10; // priority = 2
    T6CONbits.TCKPS = 0;  // T1 prescaler 1:8
    T6CONbits.TON = TMR_ON;
}

void tmr_7_init(unsigned short T_delay, unsigned short TMR_IE, unsigned short TMR_ON)
{
    T7CONbits.TON = 0;
    TMR7 = 0x0000;
    PR7 = T_delay; //
    IEC1bits.T7IE = TMR_IE;
    IPC8bits.T7IP = 0b10; // priority = 2
    T7CONbits.TCKPS = 0;  // T1 prescaler 1:8
    T7CONbits.TON = TMR_ON;
}

void OC3_init(void)
{                    // пїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅ
    OC3CON = 0x0000; // Turn off the OC3 when performing the setup
    T4CON = 0;
    OC3R = 100;      // Initialize primary Compare register
    OC3RS = 3000;    // Initialize secondary Compare register
    OC3CON = 0x0006; // Configure for PWM mode without Fault pin enabled
    T4CONbits.TCKPS = 0;
    PR4 = TMR4CLK / OC_FREQ; // Set period
    IFS0bits.T4IF = 0;       // Clear the T4 interrupt flag
    IEC0bits.T4IE = 1;       // Enable T4 interrupt
    IPC4bits.T4IP = 4;       // Set T4 interrupt priority to 4
    // T4CONbits.ON = 1;      // Enable Timer4
    // OC3CONbits.ON = 1;     // Enable OC3//
}

void uart5_init(void)
{
    U5MODEbits.USIDL = 0;                  /* Continue in Idle mode */
    U5MODEbits.LPBACK = 0;                 /* Disable LoopBack */
    U5MODEbits.PDSEL = 0b00;               /* 8-bit data, no parity */
    U5MODEbits.STSEL = 0;                  /* One Stop bit */
    U5MODEbits.BRGH = 0;                   /* 1 = High-Speed mode ? 4x baud clock enabled*/
    U5BRG = PBCLK2_ / (U5_speed * 16) - 1; // 1Mbit
    IFS5bits.U5TXIF = 0;                   /* Clear interrupt flag */
    IPC45bits.U5TXIP = 2;                  // 2 (bei 7 geht DISI nicht) is High priority, 0 is Low priority
    IPC45bits.U5TXIS = 0;                  // sub priority, 0 is Low priority
    IEC5bits.U5TXIE = 0;                   /* Enable receive interrupts */
    IFS5bits.U5RXIF = 0;                   /* Clear interrupt flag */
    IPC45bits.U5RXIP = 2;                  // 2 (bei 7 geht DISI nicht) is High priority, 0 is Low priority
    IPC45bits.U5RXIS = 0;                  // sub priority, 0 is Low priority
    IEC5bits.U5RXIE = 1;                   /* Enable receive interrupts */
    U5STAbits.UTXEN = 1;                   /* 1 = UARTx transmitter is enabled. UxTX pin is controlled by UARTx (if ON = 1*/
    U5STAbits.URXEN = 1;                   /* 1 = UARTx receiver is enabled. UxRX pin is controlled by UARTx (if ON = 1) */
    U5STAbits.UTXISEL = 0b10;              /* 10 =Interrupt is generated and asserted while the transmit buffer is empty*/
    U5MODEbits.ON = 1;                     /* Enable UART module 1 */
}

void uart4_init(void)
{
    U4MODEbits.USIDL = 0;                  /* Continue in Idle mode */
    U4MODEbits.LPBACK = 0;                 /* Disable LoopBack */
    U4MODEbits.PDSEL = 0b00;               /* 8-bit data, no parity */
    U4MODEbits.STSEL = 0;                  /* One Stop bit */
    U4MODEbits.BRGH = 0;                   /* 1 = High-Speed mode ? 4x baud clock enabled*/
    U4BRG = PBCLK2_ / (U5_speed * 16) - 1; // 1Mbit
    IFS5bits.U4TXIF = 0;                   /* Clear interrupt flag */
    IPC43bits.U4TXIP = 2;                  // 2 (bei 7 geht DISI nicht) is High priority, 0 is Low priority
    IPC43bits.U4TXIS = 0;                  // sub priority, 0 is Low priority
    IEC5bits.U4TXIE = 0;                   /* Enable receive interrupts */
    IFS5bits.U4RXIF = 0;                   /* Clear interrupt flag */
    IPC42bits.U4RXIP = 2;                  // 2 (bei 7 geht DISI nicht) is High priority, 0 is Low priority
    IPC42bits.U4RXIS = 0;                  // sub priority, 0 is Low priority
    IEC5bits.U4RXIE = 1;                   /* Enable receive interrupts */
    U4STAbits.UTXEN = 1;                   /* 1 = UARTx transmitter is enabled. UxTX pin is controlled by UARTx (if ON = 1*/
    U4STAbits.URXEN = 1;                   /* 1 = UARTx receiver is enabled. UxRX pin is controlled by UARTx (if ON = 1) */
    U4STAbits.UTXISEL = 0b10;
    U4MODEbits.ON = 1;
}

void uart3_init(void)
{
    U3MODEbits.USIDL = 0;                  /* Continue in Idle mode */
    U3MODEbits.LPBACK = 0;                 /* Disable LoopBack */
    U3MODEbits.PDSEL = 0b00;               /* 8-bit data, no parity */
    U3MODEbits.STSEL = 0;                  /* One Stop bit */
    U3MODEbits.BRGH = 0;                   /* 1 = High-Speed mode ? 4x baud clock enabled*/
    U3BRG = PBCLK2_ / (U5_speed * 16) - 1; // 1Mbit
    IFS4bits.U3TXIF = 0;                   /* Clear interrupt flag */
    IPC39bits.U3TXIP = 2;                  // 2 (bei 7 geht DISI nicht) is High priority, 0 is Low priority
    IPC39bits.U3TXIS = 0;                  // sub priority, 0 is Low priority
    IEC4bits.U3TXIE = 0;                   /* Enable receive interrupts */
    IFS4bits.U3RXIF = 0;                   /* Clear interrupt flag */
    IPC39bits.U3RXIP = 2;                  // 2 (bei 7 geht DISI nicht) is High priority, 0 is Low priority
    IPC39bits.U3RXIS = 0;                  // sub priority, 0 is Low priority
    IEC4bits.U3RXIE = 1;                   /* Enable receive interrupts */
    U3STAbits.UTXEN = 1;                   /* 1 = UARTx transmitter is enabled. UxTX pin is controlled by UARTx (if ON = 1*/
    U3STAbits.URXEN = 1;                   /* 1 = UARTx receiver is enabled. UxRX pin is controlled by UARTx (if ON = 1) */
    U3STAbits.UTXISEL = 0b10;
    U3MODEbits.ON = 1;
}

void uart2_init(void)
{
    U2MODEbits.USIDL = 0;                  /* Continue in Idle mode */
    U2MODEbits.LPBACK = 0;                 /* Disable LoopBack */
    U2MODEbits.PDSEL = 0b00;               /* 8-bit data, no parity */
    U2MODEbits.STSEL = 0;                  /* One Stop bit */
    U2MODEbits.BRGH = 0;                   /* 1 = High-Speed mode ? 4x baud clock enabled*/
    U2BRG = PBCLK2_ / (U5_speed * 16) - 1; // 1Mbit
    IFS4bits.U2TXIF = 0;                   /* Clear interrupt flag */
    IPC36bits.U2TXIP = 2;                  // 2 (bei 7 geht DISI nicht) is High priority, 0 is Low priority
    IPC36bits.U2TXIS = 0;                  // sub priority, 0 is Low priority
    IEC4bits.U2TXIE = 0;                   /* Enable receive interrupts */
    IFS4bits.U2RXIF = 0;                   /* Clear interrupt flag */
    IPC36bits.U2RXIP = 2;                  // 2 (bei 7 geht DISI nicht) is High priority, 0 is Low priority
    IPC36bits.U2RXIS = 0;                  // sub priority, 0 is Low priority
    IEC4bits.U2RXIE = 1;                   /* Enable receive interrupts */
    U2STAbits.UTXEN = 1;                   /* 1 = UARTx transmitter is enabled. UxTX pin is controlled by UARTx (if ON = 1*/
    U2STAbits.URXEN = 1;                   /* 1 = UARTx receiver is enabled. UxRX pin is controlled by UARTx (if ON = 1) */
    U2STAbits.UTXISEL = 0b10;
    U2MODEbits.ON = 1;
}

void uart1_init(void)
{
    U1MODEbits.USIDL = 0;                  /* Continue in Idle mode */
    U1MODEbits.LPBACK = 0;                 /* Disable LoopBack */
    U1MODEbits.PDSEL = 0b00;               /* 8-bit data, no parity */
    U1MODEbits.STSEL = 0;                  /* One Stop bit */
    U1MODEbits.BRGH = 0;                   /* 1 = High-Speed mode ? 4x baud clock enabled*/
    U1BRG = PBCLK2_ / (U5_speed * 16) - 1; // 1Mbit
    IFS3bits.U1TXIF = 0;                   /* Clear interrupt flag */
    IPC28bits.U1TXIP = 2;                  // 2 (bei 7 geht DISI nicht) is High priority, 0 is Low priority
    IPC28bits.U1TXIS = 0;                  // sub priority, 0 is Low priority
    IEC3bits.U1TXIE = 0;                   /* Enable receive interrupts */
    IFS3bits.U1RXIF = 0;                   /* Clear interrupt flag */
    IPC28bits.U1RXIP = 2;                  // 2 (bei 7 geht DISI nicht) is High priority, 0 is Low priority
    IPC28bits.U1RXIS = 0;                  // sub priority, 0 is Low priority
    IEC3bits.U1RXIE = 1;                   /* Enable receive interrupts */
    U1STAbits.UTXEN = 1;                   /* 1 = UARTx transmitter is enabled. UxTX pin is controlled by UARTx (if ON = 1*/
    U1STAbits.URXEN = 1;                   /* 1 = UARTx receiver is enabled. UxRX pin is controlled by UARTx (if ON = 1) */
    U1STAbits.UTXISEL = 0b10;
    U1MODEbits.ON = 1;
}

void UART1_init(unsigned int speed)
{
    U1MODE = 0x0000; // UART1 transmitter disabled

    URXISEL1 = 0b00; // Int flag is set when a character is received
    //	UTXISEL_1=0;				//Int flag is set when a char is transfering and buff is empty
    PDSEL1 = 0b00; // 8-bit data, no parity
    STSEL1 = 0;    // 1 Stop bit

    IEC3bits.U1RXIE = 0;
    IEC3bits.U1TXIE = 0;

    switch (speed)
    {
    case 1:
    {
        U1BRG = ((Fcy) / 16) / 1200 - 1; // 1200 bod
        frame_delay = Fcy / 8 / 1200 * rx_timeout1;
        break;
    }
    case 2:
    {
        U1BRG = ((Fcy) / 16) / 2400 - 1; // 2400 bod
        frame_delay = Fcy / 8 / 2400 * rx_timeout1;
        break;
    }

    case 3:
    {
        U1BRG = ((Fcy) / 16) / 4800 - 1; // 4800 bod
        frame_delay = Fcy / 8 / 4800 * rx_timeout1;
        break;
    }

    case 4:
    {
        U1BRG = ((Fcy) / 16) / 9600 - 1; // 9600 bod
        frame_delay = Fcy / 8 / 9600 * rx_timeout1;
        break;
    }

    case 5:
    {
        U1BRG = ((Fcy) / 16) / 19200 - 1; // 19200 bod
        frame_delay = Fcy / 8 / 19200 * rx_timeout1;
        break;
    }

    case 6:
    {
        U1BRG = ((Fcy) / 16) / 38400 - 1; // 38400 bod
        frame_delay = Fcy / 8 / 38400 * rx_timeout1;
        break;
    }

    case 7:
    {
        U1BRG = ((Fcy) / 16) / 57600 - 1; // 57600 bod
        frame_delay = Fcy / 8 / 57600 * rx_timeout1;
        break;
    }

    case 8:
    {
        U1BRG = ((Fcy) / 16) / 115200 - 1; // 115200 bod
        frame_delay = Fcy / 8 / 115200 * rx_timeout1;
        break;
    }

    default:
    {
        U1BRG = ((Fcy) / 16) / 38400 - 1; // 57600 bod
        frame_delay = Fcy / 8 / 38400 * rx_timeout1;
        break;
    }
    }
    UARTEN1 = 1; // UART1 enabled
    UTXEN1 = 1;
    IEC3bits.U1RXIE = 0;
    ENAB_RX1;
}

void UART2_init(unsigned int speed)
{
    U2MODE = 0x0000; // UART2 transmitter disabled

    URXISEL2 = 0b00; // Int flag is set when a character is received
    //	UTXISEL_1=0;				//Int flag is set when a char is transfering and buff is empty
    PDSEL2 = 0b00; // 8-bit data, no parity
    STSEL2 = 0;    // 1 Stop bit

    IEC4bits.U2RXIE = 0;
    IEC4bits.U2TXIE = 0;

    switch (speed)
    {
    case 1:
    {
        U2BRG = ((Fcy) / 16) / 1200 - 1; // 1200 bod
        frame_delay = Fcy / 8 / 1200 * rx_timeout1;
        break;
    }
    case 2:
    {
        U2BRG = ((Fcy) / 16) / 2400 - 1; // 2400 bod
        frame_delay = Fcy / 8 / 2400 * rx_timeout1;
        break;
    }

    case 3:
    {
        U2BRG = ((Fcy) / 16) / 4800 - 1; // 4800 bod
        frame_delay = Fcy / 8 / 4800 * rx_timeout1;
        break;
    }

    case 4:
    {
        U2BRG = ((Fcy) / 16) / 9600 - 1; // 9600 bod
        frame_delay = Fcy / 8 / 9600 * rx_timeout1;
        break;
    }

    case 5:
    {
        U2BRG = ((Fcy) / 16) / 19200 - 1; // 19200 bod
        frame_delay = Fcy / 8 / 19200 * rx_timeout1;
        break;
    }

    case 6:
    {
        U2BRG = ((Fcy) / 16) / 38400 - 1; // 38400 bod
        frame_delay = Fcy / 8 / 38400 * rx_timeout1;
        break;
    }

    case 7:
    {
        U2BRG = ((Fcy) / 16) / 57600 - 1; // 57600 bod
        frame_delay = Fcy / 8 / 57600 * rx_timeout1;
        break;
    }

    case 8:
    {
        U2BRG = ((Fcy) / 16) / 115200 - 1; // 115200 bod
        frame_delay = Fcy / 8 / 115200 * rx_timeout1;
        break;
    }

    default:
    {
        U2BRG = ((Fcy) / 16) / 38400 - 1; // 57600 bod
        frame_delay = Fcy / 8 / 38400 * rx_timeout1;
        break;
    }
    }
    UARTEN2 = 1; // UART1 enabled
    UTXEN2 = 1;
    IEC4bits.U2RXIE = 0;
    ENAB_RX2;
}

void UART4_init(unsigned int speed)
{
    U4MODE = 0x0000; // UART2 transmitter disabled

    URXISEL4 = 0b00; // Int flag is set when a character is received
    //	UTXISEL_1=0;				//Int flag is set when a char is transfering and buff is empty
    PDSEL4 = 0b00; // 8-bit data, no parity
    STSEL4 = 0;    // 1 Stop bit

    IEC5bits.U4RXIE = 0;
    IEC5bits.U4TXIE = 0;

    switch (speed)
    {
    case 1:
    {
        U4BRG = ((Fcy) / 16) / 1200 - 1; // 1200 bod
        frame_delay = Fcy / 8 / 1200 * rx_timeout1;
        break;
    }
    case 2:
    {
        U4BRG = ((Fcy) / 16) / 2400 - 1; // 2400 bod
        frame_delay = Fcy / 8 / 2400 * rx_timeout1;
        break;
    }

    case 3:
    {
        U4BRG = ((Fcy) / 16) / 4800 - 1; // 4800 bod
        frame_delay = Fcy / 8 / 4800 * rx_timeout1;
        break;
    }

    case 4:
    {
        U4BRG = ((Fcy) / 16) / 9600 - 1; // 9600 bod
        frame_delay = Fcy / 8 / 9600 * rx_timeout1;
        break;
    }

    case 5:
    {
        U4BRG = ((Fcy) / 16) / 19200 - 1; // 19200 bod
        frame_delay = Fcy / 8 / 19200 * rx_timeout1;
        break;
    }

    case 6:
    {
        U4BRG = ((Fcy) / 16) / 38400 - 1; // 38400 bod
        frame_delay = Fcy / 8 / 38400 * rx_timeout1;
        break;
    }

    case 7:
    {
        U4BRG = ((Fcy) / 16) / 57600 - 1; // 57600 bod
        frame_delay = Fcy / 8 / 57600 * rx_timeout1;
        break;
    }

    case 8:
    {
        U4BRG = ((Fcy) / 16) / 115200 - 1; // 115200 bod
        frame_delay = Fcy / 8 / 115200 * rx_timeout1;
        break;
    }

    default:
    {
        U4BRG = ((Fcy) / 16) / 38400 - 1; // 57600 bod
        frame_delay = Fcy / 8 / 38400 * rx_timeout1;
        break;
    }
    }
    UARTEN4 = 1; // UART1 enabled
    UTXEN4 = 1;
    IEC5bits.U4RXIE = 0;
    ENAB_RX4;
}

void UART5_init(unsigned int speed)
{
    U5MODE = 0x0000; // UART2 transmitter disabled

    URXISEL5 = 0b00; // Int flag is set when a character is received
    //	UTXISEL_1=0;				//Int flag is set when a char is transfering and buff is empty
    PDSEL5 = 0b00; // 8-bit data, no parity
    STSEL5 = 0;    // 1 Stop bit

    IEC5bits.U5RXIE = 0;
    IEC5bits.U5TXIE = 0;

    switch (speed)
    {
    case 1:
    {
        U5BRG = ((Fcy) / 16) / 1200 - 1; // 1200 bod
        frame_delay = Fcy / 8 / 1200 * rx_timeout1;
        break;
    }
    case 2:
    {
        U5BRG = ((Fcy) / 16) / 2400 - 1; // 2400 bod
        frame_delay = Fcy / 8 / 2400 * rx_timeout1;
        break;
    }

    case 3:
    {
        U5BRG = ((Fcy) / 16) / 4800 - 1; // 4800 bod
        frame_delay = Fcy / 8 / 4800 * rx_timeout1;
        break;
    }

    case 4:
    {
        U5BRG = ((Fcy) / 16) / 9600 - 1; // 9600 bod
        frame_delay = Fcy / 8 / 9600 * rx_timeout1;
        break;
    }

    case 5:
    {
        U5BRG = ((Fcy) / 16) / 19200 - 1; // 19200 bod
        frame_delay = Fcy / 8 / 19200 * rx_timeout1;
        break;
    }

    case 6:
    {
        U5BRG = ((Fcy) / 16) / 38400 - 1; // 38400 bod
        frame_delay = Fcy / 8 / 38400 * rx_timeout1;
        break;
    }

    case 7:
    {
        U5BRG = ((Fcy) / 16) / 57600 - 1; // 57600 bod
        frame_delay = Fcy / 8 / 57600 * rx_timeout1;
        break;
    }

    case 8:
    {
        U5BRG = ((Fcy) / 16) / 115200 - 1; // 115200 bod
        frame_delay = Fcy / 8 / 115200 * rx_timeout1;
        break;
    }

    default:
    {
        U5BRG = ((Fcy) / 16) / 38400 - 1; // 57600 bod
        frame_delay = Fcy / 8 / 38400 * rx_timeout1;
        break;
    }
    }
    UARTEN5 = 1; // UART1 enabled
    UTXEN5 = 1;
    IEC5bits.U5RXIE = 0;
    ENAB_RX5;
}

void spi5_init(void)
{
    unsigned int t_brg;
    unsigned int baudHigh;
    unsigned int baudLow;
    unsigned int errorHigh;
    unsigned int errorLow;
    unsigned int baudRate;

    baudRate = 8294400;

    SPI5CONbits.ON = 0;
    SPI5CONbits.MSTEN = 1;
    SPI5CONbits.MSSEN = 0;
    SPI5CONbits.SIDL = 0;
    SPI5CONbits.CKP = 0;
    SPI5CONbits.CKE = 1;
    SPI5CONbits.SMP = 0;
    SPI5CONbits.MODE16 = 0;
    SPI5CONbits.MODE32 = 0;
    SPI5CONbits.FRMEN = 0;
    SPI5CON2bits.AUDEN = 0;
    SPI5CONbits.ENHBUF = 1;
    t_brg = (((PBCLK2_ / baudRate) / 2) - 1);
    baudHigh = PBCLK2_ / (2 * (t_brg + 1));
    baudLow = PBCLK2_ / (2 * (t_brg + 2));
    errorHigh = baudHigh - baudRate;
    errorLow = baudRate - baudLow;
    if (errorHigh > errorLow)
    {
        t_brg++;
    }
    SPI5BRG = t_brg;
    SPI5CONbits.ON = 1;
}

void InitializeSystem(void)
{
    // PIC32MZ CPU Speed Optimizations (Cache/Wait States/Peripheral Bus Clks)
    // On reset, I+D cache is enabled for max performace setting (write-back with write allocation)
    // No wait setting required for main data RAM

    // Prefetch-cache: Enable prefetch for PFM (any PFM instructions or data)
    PRECONbits.PREFEN = 3; // предварительная выборка данных загружать их в кэш
    // Flash PM Wait States: MZ Flash runs at 2 wait states @ 200 MHz
    PRECONbits.PFMWS = 2; // чето со временем связанно
    // PBClk3 set to 8 MHz (assumes SYSCLK = 200 MHz via configuration bits)
    // Unlock Sequence
    SYSKEY = 0xAA996655;
    SYSKEY = 0x556699AA;
    // Modify PB3DIV
    PB2DIVbits.PBDIV = 3; // PBCLK = SYSCLK/8 = 24883200 Hz)
    CFGCONbits.OCACLK = 1;
    PB3DIVbits.PBDIV = 3; // PBCLK3 = SYSCLK/25 (= 200/25 = 8 MHz)
    // Lock sequence
    SYSKEY = 0x33333333;

    port_init();
    spi5_init();
    help_load = 1;
    conf_read();

    tmr_1_init(100, 0, 0);
    tmr_2_init(100, 0, 0);
    tmr_5_init(100, 0, 0);
    tmr_6_init(100, 0, 0);
    tmr_7_init(100, 0, 0);
    tmr_9_init(65000, 1, 1);
    OC3_init();
    uart5_init();
    uart4_init();
    uart3_init();
    uart2_init();
    uart1_init();
    DMA5_init();
    DMA4_init();
    DMA3_init();
    DMA2_init();
    DMA1_init();

    /* Assign PIC32MZ shadow register sets to specific CPU IPLs */
    PRISS = 0x76543210;

    /* Set Interrupt Controller for multi-vector mode */
    INTCONSET = _INTCON_MVEC_MASK; //

    /* Enable Interrupt Exceptions */
    // set the CP0 status IE bit high to turn on interrupts globally
    __builtin_enable_interrupts();

    /* Enable the peripheral */
    /* пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ */
    T2CONbits.TON = 1;
    T1CONbits.TON = 1;
    T4CONbits.ON = 1; // Enable Timer 4
    T5CONbits.ON = 1; // Enable Timer 5
    T2CONbits.ON = 1;
    OC3CONbits.ON = 1; // Enable OC3//
    //    ADCCON3bits.GSWTRG = 1;
}