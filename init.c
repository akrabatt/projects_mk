#include "extern.h"

extern __inline__ unsigned int __attribute__((always_inline)) _VirtToPhys(const void *p)
{
    // Функция _VirtToPhys используется для преобразования виртуального адреса в физический адрес.
    // Возвращает физический адрес, который является смещением на 0x40000000 от виртуального адреса,
    // если виртуальный адрес неотрицателен, иначе возвращает младшие 29 бит виртуального адреса.
    return (int)p < 0 ? ((int)p & 0x1fffffffL) : (unsigned int)((unsigned char *)p + 0x40000000L);
}

// Настройки Ethernet

#pragma config FMIIEN = OFF  // Включение/выключение интерфейса Ethernet (выключен)
#pragma config FETHIO = ON   // Выбор выводов для Ethernet (стандартные выводы)
#pragma config PGL1WAY = ON  // Разрешение однократной настройки группы разрешений (разрешена однократная настройка)
#pragma config PMDL1WAY = ON // Разрешение однократной настройки модуля периферии (разрешена однократная настройка)
#pragma config IOL1WAY = OFF // Разрешение однократной настройки выбора выводов (разрешена многократная настройка)
#pragma config FUSBIDIO = ON // Выбор модулем USB идентификатора (идентификатор USB контролируется модулем USB)

// DEVCFG2
/* DEVCFG2 - это макроопределение, которое используется для установки конфигурации DEVCFG2 (Device Configuration 2)
микроконтроллера PIC32MZ1024EFH100. DEVCFG2 определяет настройки такие как делитель входного сигнала системного PLL (FPLLIDIV),
диапазон входного сигнала системного PLL (FPLLRNG), источник тактового сигнала системного PLL (FPLLICLK), множитель системного
PLL (FPLLMULT), делитель выходного сигнала системного PLL (FPLLODIV) и частота входного сигнала USB PLL (UPLLFSEL). Эти настройки
позволяют настроить работу системного и USB PLL для достижения требуемой частоты ядра и периферийных устройств
микроконтроллера. */
#pragma config FPLLIDIV = DIV_1         // Делитель входного сигнала для системной PLL (делитель на 3)
#pragma config FPLLRNG = RANGE_8_16_MHZ // Диапазон входного сигнала для системной PLL (5-10 МГц)
#pragma config FPLLICLK = PLL_POSC      // Источник тактового сигнала для системной PLL (внешний осциллятор)
#pragma config FPLLMULT = MUL_27        // Множитель системной PLL (увеличение в 50 раз)
#pragma config FPLLODIV = DIV_2         // Делитель выходного сигнала системной PLL (делитель на 2)
#pragma config UPLLFSEL = FREQ_24MHZ    // Частота входного сигнала для USB PLL (24 МГц)

// DEVCFG1
/* DEVCFG1 - это макроопределение, используемое для установки конфигурации DEVCFG1 (Device Configuration 1)
микроконтроллера PIC32MZ1024EFH100. DEVCFG1 определяет настройки, такие как выбор источника тактового сигнала (FNOSC),
интервал счета окна DMT (DMTINTV), включение внутреннего/внешнего переключения (IESO), конфигурация основного
генератора (POSCMOD), включение осциллятора для отладки (OSCIOFNC), выбор внутреннего мультиплексора FSCM и другие.
Эти настройки позволяют настраивать основные параметры тактовой подсистемы микроконтроллера, включая выбор осциллятора,
настройки сторожевого таймера и другие параметры работы ядра. */
#pragma config FNOSC = SPLL          // Выбор источника тактового сигнала (системная PLL)
#pragma config DMTINTV = WIN_127_128 // Интервал счета DMT (127/128 от значения счетчика)
#pragma config FSOSCEN = OFF         // Включение/выключение вторичного осциллятора (выключен)
#pragma config IESO = ON             // Включение/выключение автопереключения источника тактового сигнала (включено)
#pragma config POSCMOD = EC          // Режим настройки осциллятора (внешний кварц)
#pragma config OSCIOFNC = OFF        // Настройка вывода CLKO (выключено)
#pragma config FCKSM = CSECME        // Настройка переключения тактового сигнала и монитора (переключение тактового сигнала и монитор включены)
#pragma config WDTPS = PS1048576     // Предделитель сторожевого таймера (1:1048576)
#pragma config WDTSPGM = STOP        // Остановка сторожевого таймера во время программирования Flash (сторожевой таймер останавливается во время программирования Flash)
#pragma config WINDIS = NORMAL       // Режим окошечного сторожевого таймера (нормальный)
#pragma config FWDTEN = OFF          // Включение/выключение сторожевого таймера (выключено)
#pragma config FWDTWINSZ = WINSZ_25  // Размер окошечного сторожевого таймера (25%)
#pragma config DMTCNT = DMT31        // Выбор значения счетчика Deadman Timer (2^31)
#pragma config FDMTEN = OFF          // Включение/выключение Deadman Timer (выключено)

// DEVCFG0
/* DEVCFG0 - это макроопределение, используемое для установки конфигурации DEVCFG0 (Device Configuration 0) микроконтроллера
PIC32MZ1024EFH100. DEVCFG0 определяет настройки, такие как разрешение отладчика на фоновый режим (DEBUG), включение JTAG
(JTAGEN), выбор канала связи ICE/ICD (ICESEL), разрешение трассировки (TRCEN), выбор ISA загрузочного кода (BOOTISA),
конфигурацию ECC для Flash-памяти (FECCCON), режим сна Flash (FSLEEP), доступ к режиму отладки для CPU (DBGPER), программный
сброс (SMCLR), усиление вторичного осциллятора (SOSCGAIN), включение ускорения вторичного осциллятора (SOSCBOOST), усиление
основного осциллятора (POSCGAIN), включение ускорения основного осциллятора (POSCBOOST), настройка EJTAG (EJTAGBEN), а также
кодовая защита (CP). Эти настройки определяют различные аспекты работы микроконтроллера, такие как настройки отладки, режимы сна,
конфигурация интерфейсов и другие параметры. */
#pragma config DEBUG = OFF            // Включение/выключение отладчика (выключен)
#pragma config JTAGEN = OFF           // Включение/выключение JTAG (выключен)
#pragma config ICESEL = ICS_PGx1      // Выбор канала общения ICE/ICD (PGEC2/PGED2)
#pragma config TRCEN = ON             // Включение/выключение трассировки (включена)
#pragma config BOOTISA = MIPS32       // Выбор ISA для загрузки (MIPS32)
#pragma config FECCCON = OFF_UNLOCKED // Конфигурация динамической ECC для Flash (ECC и динамическая ECC отключены)
#pragma config FSLEEP = OFF           // Режим сна для Flash (Flash от//ключается во время сна)
#pragma config DBGPER = ALLOW_PG2     // Разрешение доступа отладочного режима к CPU (разрешен доступ к Permission Group 2)
#pragma config SMCLR = MCLR_NORM      // Включение/выключение мягкого сброса (нормальный режим сброса)
#pragma config SOSCGAIN = GAIN_2X     // Настройка усиления вторичного осциллятора (усиление в 2 раза)
#pragma config SOSCBOOST = ON         // Включение/выключение ускорения старта вторичного осциллятора (ускорение старта осциллятора)
#pragma config POSCGAIN = GAIN_2X     // Настройка усиления первичного осциллятора (усиление в 2 раза)
#pragma config POSCBOOST = ON         // Включение/выключение ускорения старта первичного осциллятора (ускорение старта осциллятора)
#pragma config EJTAGBEN = NORMAL      // Загрузка EJTAG (нормальное EJTAG-функциональность)

// DEVCP0
/* DEVCP0 - это макроопределение, используемое для установки конфигурации DEVCP0 (Device Code Protection 0)
микроконтроллера PIC32MZ1024EFH100. DEVCP0 определяет настройки защиты кода, такие как защита кода (CP),
которая может быть включена или выключена. Когда защита кода включена (CP = ON), это означает, что защита
программного кода активна, что делает невозможным чтение и/или запись программного кода в микроконтроллер без
специальных разрешений или безопасных процедур. */
#pragma config CP = OFF // Защита кода (защита отключена)

/*** Ports System Service Configuration ***/

// Настройки порта A
#define SYS_PORT_A_ANSEL 0x0600 // Настройка регистра ANSEL для порта A
#define SYS_PORT_A_TRIS 0xc6e3  // Настройка регистра TRIS для порта A
#define SYS_PORT_A_LAT 0x0      // Настройка регистра LAT для порта A
#define SYS_PORT_A_ODC 0x0      // Настройка регистра ODC для порта A
#define SYS_PORT_A_CNPU 0x0     // Настройка регистра CNPU для порта A
#define SYS_PORT_A_CNPD 0x0     // Настройка регистра CNPD для порта A
#define SYS_PORT_A_CNEN 0x0     // Настройка регистра CNEN для порта A

// Настройки порта B
#define SYS_PORT_B_ANSEL 0x8000 // Настройка регистра ANSEL для порта B
#define SYS_PORT_B_TRIS 0xe6ff  // Настройка регистра TRIS для порта B
#define SYS_PORT_B_LAT 0x8000   // Настройка регистра LAT для порта B
#define SYS_PORT_B_ODC 0x0      // Настройка регистра ODC для порта B
#define SYS_PORT_B_CNPU 0x0     // Настройка регистра CNPU для порта B
#define SYS_PORT_B_CNPD 0x0     // Настройка регистра CNPD для порта B
#define SYS_PORT_B_CNEN 0x0     // Настройка регистра CNEN для порта B

// Настройки порта C
#define SYS_PORT_C_ANSEL 0x0   // Настройка регистра ANSEL для порта C
#define SYS_PORT_C_TRIS 0xb01e // Настройка регистра TRIS для порта C
#define SYS_PORT_C_LAT 0x0     // Настройка регистра LAT для порта C
#define SYS_PORT_C_ODC 0x0     // Настройка регистра ODC для порта C
#define SYS_PORT_C_CNPU 0x0    // Настройка регистра CNPU для порта C
#define SYS_PORT_C_CNPD 0x0    // Настройка регистра CNPD для порта C
#define SYS_PORT_C_CNEN 0x0    // Настройка регистра CNEN для порта C

// Настройки порта D
#define SYS_PORT_D_ANSEL 0x0 // Настройка регистра ANSEL для порта D
#define SYS_PORT_D_TRIS 0x14 // Настройка регистра TRIS для порта D
#define SYS_PORT_D_LAT 0x0   // Настройка регистра LAT для порта D
#define SYS_PORT_D_ODC 0x0   // Настройка регистра ODC для порта D
#define SYS_PORT_D_CNPU 0x0  // Настройка регистра CNPU для порта D
#define SYS_PORT_D_CNPD 0x0  // Настройка регистра CNPD для порта D
#define SYS_PORT_D_CNEN 0x0  // Настройка регистра CNEN для порта D

// Настройки порта E
#define SYS_PORT_E_ANSEL 0x0  // Настройка регистра ANSEL для порта E
#define SYS_PORT_E_TRIS 0x3e0 // Настройка регистра TRIS для порта E
#define SYS_PORT_E_LAT 0x10   // Настройка регистра LAT для порта E
#define SYS_PORT_E_ODC 0x0    // Настройка регистра ODC для порта E
#define SYS_PORT_E_CNPU 0x0   // Настройка регистра CNPU для порта E
#define SYS_PORT_E_CNPD 0x0   // Настройка регистра CNPD для порта E
#define SYS_PORT_E_CNEN 0x0   // Настройка регистра CNEN для порта E

// Настройки порта F
#define SYS_PORT_F_ANSEL 0x0   // Настройка регистра ANSEL для порта F
#define SYS_PORT_F_TRIS 0x113b // Настройка регистра TRIS для порта F
#define SYS_PORT_F_LAT 0x0     // Настройка регистра LAT для порта F
#define SYS_PORT_F_ODC 0x0     // Настройка регистра ODC для порта F
#define SYS_PORT_F_CNPU 0x0    // Настройка регистра CNPU для порта F
#define SYS_PORT_F_CNPD 0x0    // Настройка регистра CNPD для порта F
#define SYS_PORT_F_CNEN 0x0    // Настройка регистра CNEN для порта F

// Настройки порта G
#define SYS_PORT_G_ANSEL 0x0   // Настройка регистра ANSEL для порта G
#define SYS_PORT_G_TRIS 0x8343 // Настройка регистра TRIS для порта G
#define SYS_PORT_G_LAT 0x0     // Настройка регистра LAT для порта G
#define SYS_PORT_G_ODC 0x0     // Настройка регистра ODC для порта G
#define SYS_PORT_G_CNPU 0x0    // Настройка регистра CNPU для порта G
#define SYS_PORT_G_CNPD 0x0    // Настройка регистра CNPD для порта G
#define SYS_PORT_G_CNEN 0x0    // Настройка регистра CNEN для порта G

/**
 * @brief Инициализация портов ввода-вывода микроконтроллера.
 *
 * Эта функция настраивает порты ввода-вывода микроконтроллера согласно заданным параметрам:
 * - Настройка портов A, B, C, D, E, F, G в соответствии с предопределенными значениями направления и аналоговых входов.
 * - Установка состояния порта D в соответствии с предопределенными значениями.
 * - Установка специфических настроек для некоторых портов и их функций.
 * - Назначение функций для приема и передачи данных UART на соответствующих портах.
 * - Назначение функции SPI для порта B, 10-й ножки.
 *
 * @param void
 * @return void
 */
void port_init(void)
{
    // Настройка порта A
    TRISA = SYS_PORT_A_TRIS;   // Установка направления порта A в соответствии с предопределенными значениями
    ANSELA = SYS_PORT_A_ANSEL; // Настройка аналоговых входов порта A в соответствии с предопределенными значениями

    // Настройка порта B
    TRISB = SYS_PORT_B_TRIS;   // Установка направления порта B в соответствии с предопределенными значениями
    ANSELB = SYS_PORT_B_ANSEL; // Настройка аналоговых входов порта B в соответствии с предопределенными значениями

    // Настройка порта C
    TRISC = SYS_PORT_C_TRIS;   // Установка направления порта C в соответствии с предопределенными значениями
    ANSELC = SYS_PORT_C_ANSEL; // Настройка аналоговых входов порта C в соответствии с предопределенными значениями

    // Настройка порта D
    TRISD = SYS_PORT_D_TRIS; // Установка направления порта D в соответствии с предопределенными значениями
    ANSELD = 0;              // Отключение аналоговых входов порта D
    LATD = SYS_PORT_D_LAT;   // Установка состояния порта D в соответствии с предопределенными значениями

    // Настройка порта E
    TRISE = SYS_PORT_E_TRIS;   // Установка направления порта E в соответствии с предопределенными значениями
    ANSELE = SYS_PORT_E_ANSEL; // Настройка аналоговых входов порта E в соответствии с предопределенными значениями

    // Настройка порта F
    TRISF = SYS_PORT_F_TRIS;   // Установка направления порта F в соответствии с предопределенными значениями
    ANSELF = SYS_PORT_F_ANSEL; // Настройка аналоговых входов порта F в соответствии с предопределенными значениями

    // Настройка порта G
    TRISG = SYS_PORT_G_TRIS;   // Установка направления порта G в соответствии с предопределенными значениями
    ANSELG = SYS_PORT_G_ANSEL; // Настройка аналоговых входов порта G в соответствии с предопределенными значениями

    // Дополнительная настройка некоторых специфических портов и их функций
    TRISBbits.TRISB15 = 0; // Установка направления порта B, 15-й ножки, в качестве выхода для управления 3-м UART
    TRISDbits.TRISD1 = 0;  // Установка направления порта D, 1-й ножки, в качестве выхода для управления 1-м UART

    // Назначение функций для приема данных UART на соответствующих портах
    U1RXRbits.U1RXR = 0b0000; // Подключение приемника UART1 к порту RPD2
    U2RXRbits.U2RXR = 0b0100; // Подключение приемника UART2 к порту RPD4
    U3RXRbits.U3RXR = 0b0111; // Подключение приемника UART3 к порту RPC13
    U4RXRbits.U4RXR = 0b0010; // Подключение приемника UART4 к порту RPB14
    U5RXRbits.U5RXR = 0b1101; // Подключение приемника UART5 к порту RPA14

    // Назначение функций для передачи данных UART на соответствующих портах
    RPD3Rbits.RPD3R = 0b0001;   // Подключение передатчика UART1 к порту RPD3
    RPD5Rbits.RPD5R = 0b0010;   // Подключение передатчика UART2 к порту RPD5
    RPC14Rbits.RPC14R = 0b0001; // Подключение передатчика UART3 к порту RPC14
    RPF12Rbits.RPF12R = 0b0010; // Подключение передатчика UART4 к порту RPF12
    RPA15Rbits.RPA15R = 0b0011; // Подключение передатчика UART5 к порту RPA15

    // Назначение функции SPI для порта B, 10-й ножки
    RPB10Rbits.RPB10R = 0b1001; // Подключение SPI к порту RPB10
}

/**
 * @brief Инициализация таймера T1.
 *
 * Эта функция инициализирует таймер T1 с заданными параметрами:
 * - Отключает таймер T1 перед началом настройки.
 * - Устанавливает начальное значение таймера T1 в 0.
 * - Устанавливает значение предварительной загрузки для сравнения с таймером T1.
 * - Устанавливает бит разрешения прерывания таймера T1 в соответствии с переданным значением.
 * - Устанавливает приоритет прерывания таймера T1.
 * - Устанавливает предделитель таймера T1 на значение 1:1.
 * - Включает таймер T1 в соответствии с переданным значением.
 *
 * @param T_delay Значение предварительной загрузки для сравнения с таймером T1.
 * @param TMR_IE Бит разрешения прерывания таймера T1.
 * @param TMR_ON Значение для включения таймера T1.
 * @return void
 */
void tmr_1_init(unsigned short T_delay, unsigned short TMR_IE, unsigned short TMR_ON)
{
    T1CONbits.TON = 0;      // Отключение таймера T1 перед началом настройки
    TMR1 = 0x0000;          // Установка начального значения таймера T1 в 0
    PR1 = T_delay;          // Установка значения предварительной загрузки для сравнения с таймером T1
    IEC0bits.T1IE = TMR_IE; // Установка бита разрешения прерывания таймера T1 в соответствии с переданным значением
    IPC1bits.T1IP = 0b10;   // Установка приоритета прерывания таймера T1 в 2
    T1CONbits.TCKPS = 0;    // Установка предделителя таймера T1 на значение 1:1
    T1CONbits.TON = TMR_ON; // Включение таймера T1 в соответствии с переданным значением
}

/**
 * @brief Инициализация таймера T2.
 *
 * Эта функция настраивает таймер T2 согласно заданным параметрам:
 * - Отключает таймер T2 перед началом настройки.
 * - Устанавливает начальное значение таймера T2 в 0.
 * - Устанавливает значение предварительной загрузки для сравнения с таймером T2.
 * - Устанавливает бит разрешения прерывания таймера T2 в соответствии с переданным значением.
 * - Устанавливает приоритет прерывания таймера T2.
 * - Устанавливает предделитель таймера T2 на значение 1:1.
 * - Включает таймер T2 в соответствии с переданным значением.
 *
 * @param T_delay Значение предварительной загрузки для сравнения с таймером T2.
 * @param TMR_IE Бит разрешения прерывания таймера T2 (0 - выключено, 1 - включено).
 * @param TMR_ON Флаг включения таймера T2 (0 - выключено, 1 - включено).
 * @return void
 */
void tmr_2_init(unsigned short T_delay, unsigned short TMR_IE, unsigned short TMR_ON)
{
    T2CONbits.TON = 0;      // Отключение таймера T2 перед началом настройки
    TMR2 = 0x0000;          // Установка начального значения таймера T2 в 0
    PR2 = T_delay;          // Установка значения предварительной загрузки для сравнения с таймером T2
    IEC0bits.T2IE = TMR_IE; // Установка бита разрешения прерывания таймера T2 в соответствии с переданным значением
    IPC2bits.T2IP = 0b10;   // Установка приоритета прерывания таймера T2 в 2
    T2CONbits.TCKPS = 0;    // Установка предделителя таймера T2 на значение 1:1
    T2CONbits.TON = TMR_ON; // Включение таймера T2 в соответствии с переданным значением
}

/**
 * @brief Инициализация таймера T3.
 *
 * Эта функция настраивает таймер T3 согласно заданным параметрам:
 * - Отключает таймер T3 перед началом настройки.
 * - Устанавливает начальное значение таймера T3 в 0.
 * - Устанавливает значение предварительной загрузки для сравнения с таймером T3.
 * - Устанавливает бит разрешения прерывания таймера T3 в соответствии с переданным значением.
 * - Устанавливает приоритет прерывания таймера T3.
 * - Устанавливает предделитель таймера T3 на значение 1:1.
 * - Включает таймер T3 в соответствии с переданным значением.
 *
 * @param T_delay Значение предварительной загрузки для сравнения с таймером T3.
 * @param TMR_IE Бит разрешения прерывания таймера T3 (0 - выключено, 1 - включено).
 * @param TMR_ON Флаг включения таймера T3 (0 - выключено, 1 - включено).
 * @return void
 */
void tmr_3_init(unsigned short T_delay, unsigned short TMR_IE, unsigned short TMR_ON)
{
    T3CONbits.TON = 0;      // Отключение таймера T3 перед началом настройки
    TMR3 = 0x0000;          // Установка начального значения таймера T3 в 0
    PR3 = T_delay;          // Установка значения предварительной загрузки для сравнения с таймером T3
    IEC0bits.T3IE = TMR_IE; // Установка бита разрешения прерывания таймера T3 в соответствии с переданным значением
    IPC3bits.T3IP = 0b10;   // Установка приоритета прерывания таймера T3 в 2
    T3CONbits.TCKPS = 0;    // Установка предделителя таймера T3 на значение 1:1
    T3CONbits.TON = TMR_ON; // Включение таймера T3 в соответствии с переданным значением
}

/**
 * @brief Инициализация таймера T4.
 *
 * Эта функция настраивает таймер T4 согласно заданным параметрам:
 * - Отключает таймер T4 перед началом настройки.
 * - Устанавливает начальное значение таймера T4 в 0.
 * - Устанавливает значение предварительной загрузки для сравнения с таймером T4.
 * - Устанавливает бит разрешения прерывания таймера T4 в соответствии с переданным значением.
 * - Устанавливает приоритет прерывания таймера T4.
 * - Устанавливает предделитель таймера T4 на значение 1:1.
 * - Включает таймер T4 в соответствии с переданным значением.
 *
 * @param T_delay Значение предварительной загрузки для сравнения с таймером T4.
 * @param TMR_IE Бит разрешения прерывания таймера T4 (0 - выключено, 1 - включено).
 * @param TMR_ON Флаг включения таймера T4 (0 - выключено, 1 - включено).
 * @return void
 */
void tmr_4_init(unsigned short T_delay, unsigned short TMR_IE, unsigned short TMR_ON)
{
    T4CONbits.TON = 0;      // Отключение таймера T4 перед началом настройки
    TMR4 = 0x0000;          // Установка начального значения таймера T4 в 0
    PR4 = T_delay;          // Установка значения предварительной загрузки для сравнения с таймером T4
    IEC0bits.T4IE = TMR_IE; // Установка бита разрешения прерывания таймера T4 в соответствии с переданным значением
    IPC4bits.T4IP = 0b10;   // Установка приоритета прерывания таймера T4 в 2
    T4CONbits.TCKPS = 0;    // Установка предделителя таймера T4 на значение 1:1
    T4CONbits.TON = TMR_ON; // Включение таймера T4 в соответствии с переданным значением
}

/**
 * @brief Инициализация таймера T5.
 *
 * Эта функция настраивает таймер T5 согласно заданным параметрам:
 * - Отключает таймер T5 перед началом настройки.
 * - Устанавливает начальное значение таймера T5 в 0.
 * - Устанавливает значение предварительной загрузки для сравнения с таймером T5.
 * - Устанавливает бит разрешения прерывания таймера T5 в соответствии с переданным значением.
 * - Устанавливает приоритет прерывания таймера T5.
 * - Устанавливает предделитель таймера T5 на значение 1:1.
 * - Включает таймер T5 в соответствии с переданным значением.
 *
 * @param T_delay Значение предварительной загрузки для сравнения с таймером T5.
 * @param TMR_IE Бит разрешения прерывания таймера T5 (0 - выключено, 1 - включено).
 * @param TMR_ON Флаг включения таймера T5 (0 - выключено, 1 - включено).
 * @return void
 */
void tmr_5_init(unsigned short T_delay, unsigned short TMR_IE, unsigned short TMR_ON)
{
    T5CONbits.TON = 0;      // Отключение таймера T5 перед началом настройки
    TMR5 = 0x0000;          // Установка начального значения таймера T5 в 0
    PR5 = T_delay;          // Установка значения предварительной загрузки для сравнения с таймером T5
    IEC0bits.T5IE = TMR_IE; // Установка бита разрешения прерывания таймера T5 в соответствии с переданным значением
    IPC6bits.T5IP = 0b10;   // Установка приоритета прерывания таймера T5 в 2
    T5CONbits.TCKPS = 0;    // Установка предделителя таймера T5 на значение 1:1
    T5CONbits.TON = TMR_ON; // Включение таймера T5 в соответствии с переданным значением
}

/**
 * @brief Инициализация таймера T6.
 *
 * Эта функция настраивает таймер T6 согласно заданным параметрам:
 * - Отключает таймер T6 перед началом настройки.
 * - Устанавливает начальное значение таймера T6 в 0.
 * - Устанавливает значение предварительной загрузки для сравнения с таймером T6.
 * - Устанавливает бит разрешения прерывания таймера T6 в соответствии с переданным значением.
 * - Устанавливает приоритет прерывания таймера T6.
 * - Устанавливает предделитель таймера T6 на значение 1:1.
 * - Включает таймер T6 в соответствии с переданным значением.
 *
 * @param T_delay Значение предварительной загрузки для сравнения с таймером T6.
 * @param TMR_IE Бит разрешения прерывания таймера T6 (0 - выключено, 1 - включено).
 * @param TMR_ON Флаг включения таймера T6 (0 - выключено, 1 - включено).
 * @return void
 */
void tmr_6_init(unsigned short T_delay, unsigned short TMR_IE, unsigned short TMR_ON)
{
    T6CONbits.TON = 0;      // Отключение таймера T6 перед началом настройки
    TMR6 = 0x0000;          // Установка начального значения таймера T6 в 0
    PR6 = T_delay;          // Установка значения предварительной загрузки для сравнения с таймером T6
    IEC0bits.T6IE = TMR_IE; // Установка бита разрешения прерывания таймера T6 в соответствии с переданным значением
    IPC7bits.T6IP = 0b10;   // Установка приоритета прерывания таймера T6 в 2
    T6CONbits.TCKPS = 0;    // Установка предделителя таймера T6 на значение 1:1
    T6CONbits.TON = TMR_ON; // Включение таймера T6 в соответствии с переданным значением
}

/**
 * @brief Инициализация таймера T7.
 *
 * Функция инициализирует таймер T7 с учетом заданных параметров:
 * - Отключает таймер T7 перед настройкой.
 * - Сбрасывает счетчик таймера T7 (устанавливает счетчик в 0).
 * - Устанавливает значение периода таймера T7 (значение, при котором счетчик сбрасывается и генерируется прерывание).
 * - Включает/отключает прерывание от таймера T7 в зависимости от переданного значения.
 * - Устанавливает приоритет прерывания от таймера T7.
 * - Устанавливает предделитель таймера T7 (деление на соответствующее значение).
 * - Включает/отключает таймер T7 в зависимости от переданного значения.
 *
 * @param T_delay Значение периода таймера T7.
 * @param TMR_IE Флаг включения/отключения прерывания от таймера T7 (1 - включить, 0 - выключить).
 * @param TMR_ON Флаг включения/отключения таймера T7 (1 - включить, 0 - выключить).
 * @return void
 */
void tmr_7_init(unsigned short T_delay, unsigned short TMR_IE, unsigned short TMR_ON)
{
    T7CONbits.TON = 0;      // Отключение таймера 7 перед настройкой (0 - выключен, 1 - включен)
    TMR7 = 0x0000;          // Сброс счетчика таймера 7 (установка счетчика в 0)
    PR7 = T_delay;          // Установка значения периода таймера 7 (значение, при котором счетчик сбрасывается и генерируется прерывание)
    IEC1bits.T7IE = TMR_IE; // Включение/отключение прерывания от таймера 7 (1 - включить, 0 - выключить)
    IPC8bits.T7IP = 0b10;   // Установка приоритета прерывания от таймера 7 (значение приоритета)
    T7CONbits.TCKPS = 0;    // Установка предделителя таймера 7 (0 - без предделителя, 1-7 - деление на соответствующее значение)
    T7CONbits.TON = TMR_ON; // Включение/отключение таймера 7 (1 - включить, 0 - выключить)
}

/**
 * @brief Инициализация таймера T9.
 *
 * Функция инициализирует таймер T9 с учетом заданных параметров:
 * - Отключает таймер T9 перед настройкой.
 * - Устанавливает начальное значение таймера T9.
 * - Устанавливает значение предварительной загрузки для сравнения с таймером T9.
 * - Устанавливает бит разрешения прерывания таймера T9 в зависимости от переданного значения.
 * - Устанавливает приоритет прерывания таймера T9.
 * - Устанавливает предделитель таймера T9 на значение 1:256.
 * - Включает таймер T9 в соответствии с переданным значением.
 *
 * @param T9_delay Значение предварительной загрузки для сравнения с таймером T9.
 * @param TMR9_IE Флаг разрешения прерывания от таймера T9 (1 - включить, 0 - выключить).
 * @param TMR9_ON Флаг включения таймера T9 (1 - включить, 0 - выключить).
 * @return void
 */
void tmr_9_init(unsigned short T9_delay, unsigned short TMR9_IE, unsigned short TMR9_ON)
{
    T9CONbits.TON = 0;       // Отключение таймера T9 перед началом настройки
    TMR9 = 0x0000;           // Установка начального значения таймера T9 в 0
    PR9 = T9_delay;          // Установка значения предварительной загрузки для сравнения с таймером T9
    IEC1bits.T9IE = TMR9_IE; // Установка бита разрешения прерывания таймера T9 в соответствии с переданным значением
    IPC10bits.T9IP = 0b10;   // Установка приоритета прерывания таймера T9 в 2
    T9CONbits.TCKPS = 0b11;  // Установка предделителя таймера T9 на значение 1:256
    T9CONbits.TON = TMR9_ON; // Включение таймера T9 в соответствии с переданным значением
}

/* инициализация модуля сравнения */
void OC3_init(void)
{                            // Начало функции инициализации модуля сравнения вывода OC3
    OC3CON = 0x0000;         // Выключаем модуль сравнения OC3 перед его настройкой
    T4CON = 0;               // Сбрасываем настройки таймера 4
    OC3R = 100;              // Инициализируем основной регистр сравнения
    OC3RS = 3000;            // Инициализируем вторичный регистр сравнения
    OC3CON = 0x0006;         // Настройка режима ШИМ без использования пина Fault
    T4CONbits.TCKPS = 0;     // Устанавливаем предделитель таймера 4 на значение 1:1
    PR4 = TMR4CLK / OC_FREQ; // Устанавливаем период таймера 4
    IFS0bits.T4IF = 0;       // Сбрасываем флаг прерывания таймера 4
    IEC0bits.T4IE = 1;       // Разрешаем прерывания от таймера 4
    IPC4bits.T4IP = 4;       // Устанавливаем приоритет прерывания таймера 4
    // T4CONbits.ON = 1;      // Включаем таймер 4
    // OC3CONbits.ON = 1;     // Включаем модуль сравнения OC3
} // Конец функции инициализации модуля сравнения вывода OC3
/* Этот код предназначен для инициализации модуля сравнения вывода OC3 (Output Compare 3) на микроконтроллере.
Он настраивает регистры и конфигурацию модуля сравнения для генерации сигнала ШИМ (Широтно-Импульсной Модуляции) без
использования пина Fault. Таймер 4 используется в качестве источника сигнала тактирования для генерации ШИМ. После
инициализации этот модуль готов к использованию для управления ШИМ-сигналом. */

/* зона инициализации юартов */
// инициализация 5го порта
void uart5_init(void)
{
    U5MODEbits.USIDL = 0;                  // Продолжаем работу UART5 в режиме простоя
    U5MODEbits.LPBACK = 0;                 // Отключаем режим обратной связи
    U5MODEbits.PDSEL = 0b00;               // 8-бит данных, без проверки четности
    U5MODEbits.STSEL = 0;                  // Один стоп-бит
    U5MODEbits.BRGH = 0;                   // Низкоскоростной режим (если 1, то высокоскоростной)
    U5BRG = PBCLK2_ / (U5_speed * 16) - 1; // Устанавливаем скорость передачи данных
    IFS5bits.U5TXIF = 0;                   // Сбрасываем флаг прерывания передачи
    IPC45bits.U5TXIP = 2;                  // Приоритет прерывания передачи - высокий
    IPC45bits.U5TXIS = 0;                  // Подприоритет прерывания передачи - низкий
    IEC5bits.U5TXIE = 0;                   // Разрешаем прерывания при приеме данных
    IFS5bits.U5RXIF = 0;                   // Сбрасываем флаг прерывания приема
    IPC45bits.U5RXIP = 2;                  // Приоритет прерывания приема - высокий
    IPC45bits.U5RXIS = 0;                  // Подприоритет прерывания приема - низкий
    IEC5bits.U5RXIE = 1;                   // Разрешаем прерывания при приеме данных
    U5STAbits.UTXEN = 1;                   // Включаем передатчик UART5
    U5STAbits.URXEN = 1;                   // Включаем приемник UART5
    U5STAbits.UTXISEL = 0b10;              // Генерируем прерывание, когда буфер передачи пуст
    U5MODEbits.ON = 1;                     // Включаем модуль UART5
}
/* Эта функция инициализирует модуль UART5 с заданными параметрами, включает передающий и приемный режимы,
а также включает прерывания для передачи и приема данных. */

void uart4_init(void)
{
    U4MODEbits.USIDL = 0;                  /* Продолжать работу UART4 в режиме простоя */
    U4MODEbits.LPBACK = 0;                 /* Отключить режим обратной связи */
    U4MODEbits.PDSEL = 0b00;               /* Установить формат данных: 8 бит, без проверки четности */
    U4MODEbits.STSEL = 0;                  /* Установить один стоп-бит */
    U4MODEbits.BRGH = 0;                   /* Выбрать низкоскоростной режим передачи */
    U4BRG = PBCLK2_ / (U5_speed * 16) - 1; // Настроить скорость передачи данных
    IFS5bits.U4TXIF = 0;                   /* Сбросить флаг прерывания передачи данных */
    IPC43bits.U4TXIP = 2;                  /* Установить приоритет прерывания передачи данных */
    IPC43bits.U4TXIS = 0;                  /* Установить подприоритет прерывания передачи данных */
    IEC5bits.U4TXIE = 0;                   /* Разрешить прерывания при передаче данных */
    IFS5bits.U4RXIF = 0;                   /* Сбросить флаг прерывания приема данных */
    IPC42bits.U4RXIP = 2;                  /* Установить приоритет прерывания приема данных */
    IPC42bits.U4RXIS = 0;                  /* Установить подприоритет прерывания приема данных */
    IEC5bits.U4RXIE = 1;                   /* Разрешить прерывания при приеме данных */
    U4STAbits.UTXEN = 1;                   /* Включить передатчик UART4 */
    U4STAbits.URXEN = 1;                   /* Включить приемник UART4 */
    U4STAbits.UTXISEL = 0b10;              /* Установить условие генерации прерывания при передаче данных (пустой буфер) */
    U4MODEbits.ON = 1;                     /* Включить модуль UART4 */
}
/* Эта функция инициализирует модуль UART4 с заданными параметрами, включает передающий и приемный режимы,
а также включает прерывания для передачи и приема данных. */

void uart3_init(void)
{
    U3MODEbits.USIDL = 0;                  /* Продолжать работу UART3 в режиме простоя */
    U3MODEbits.LPBACK = 0;                 /* Отключить режим обратной связи */
    U3MODEbits.PDSEL = 0b00;               /* Установить формат данных: 8 бит, без проверки четности */
    U3MODEbits.STSEL = 0;                  /* Установить один стоп-бит */
    U3MODEbits.BRGH = 0;                   /* Выбрать низкоскоростной режим передачи */
    U3BRG = PBCLK2_ / (U5_speed * 16) - 1; // Настроить скорость передачи данных
    IFS4bits.U3TXIF = 0;                   /* Сбросить флаг прерывания передачи данных */
    IPC39bits.U3TXIP = 2;                  /* Установить приоритет прерывания передачи данных */
    IPC39bits.U3TXIS = 0;                  /* Установить подприоритет прерывания передачи данных */
    IEC4bits.U3TXIE = 0;                   /* Разрешить прерывания при передаче данных */
    IFS4bits.U3RXIF = 0;                   /* Сбросить флаг прерывания приема данных */
    IPC39bits.U3RXIP = 2;                  /* Установить приоритет прерывания приема данных */
    IPC39bits.U3RXIS = 0;                  /* Установить подприоритет прерывания приема данных */
    IEC4bits.U3RXIE = 1;                   /* Разрешить прерывания при приеме данных */
    U3STAbits.UTXEN = 1;                   /* Включить передатчик UART3 */
    U3STAbits.URXEN = 1;                   /* Включить приемник UART3 */
    U3STAbits.UTXISEL = 0b10;              /* Установить условие генерации прерывания при передаче данных (пустой буфер) */
    U3MODEbits.ON = 1;                     /* Включить модуль UART3 */
}
/* Эта функция инициализирует модуль UART3 с заданными параметрами, включает передающий и приемный режимы,
а также включает прерывания для передачи и приема данных. */
void uart2_init(void)
{
    U2MODEbits.USIDL = 0;                  /* Продолжить работу UART2 в режиме простоя */
    U2MODEbits.LPBACK = 0;                 /* Отключить режим обратной связи */
    U2MODEbits.PDSEL = 0b00;               /* 8-битные данные, без проверки четности */
    U2MODEbits.STSEL = 0;                  /* Один стоп-бит */
    U2MODEbits.BRGH = 0;                   /* Режим высокой скорости передачи выключен */
    U2BRG = PBCLK2_ / (U5_speed * 16) - 1; // Установить скорость передачи данных
    IFS4bits.U2TXIF = 0;                   /* Сбросить флаг прерывания передачи данных */
    IPC36bits.U2TXIP = 2;                  /* Установить приоритет прерывания передачи данных */
    IPC36bits.U2TXIS = 0;                  /* Установить подприоритет прерывания передачи данных */
    IEC4bits.U2TXIE = 0;                   /* Разрешить прерывания при передаче данных */
    IFS4bits.U2RXIF = 0;                   /* Сбросить флаг прерывания приема данных */
    IPC36bits.U2RXIP = 2;                  /* Установить приоритет прерывания приема данных */
    IPC36bits.U2RXIS = 0;                  /* Установить подприоритет прерывания приема данных */
    IEC4bits.U2RXIE = 1;                   /* Разрешить прерывания при приеме данных */
    U2STAbits.UTXEN = 1;                   /* Включить передатчик UART2 */
    U2STAbits.URXEN = 1;                   /* Включить приемник UART2 */
    U2STAbits.UTXISEL = 0b10;              /* Установить условие генерации прерывания при передаче данных (пустой буфер) */
    U2MODEbits.ON = 1;                     /* Включить модуль UART2 */
}
/* Эта функция инициализирует модуль UART2 с заданными параметрами, включает передающий и приемный режимы,
а также включает прерывания для передачи и приема данных. */

void uart1_init(void)
{
    U1MODEbits.USIDL = 0;                  /* Продолжить работу UART1 в режиме простоя */
    U1MODEbits.LPBACK = 0;                 /* Отключить режим обратной связи */
    U1MODEbits.PDSEL = 0b00;               /* 8-битные данные, без проверки четности */
    U1MODEbits.STSEL = 0;                  /* Один стоп-бит */
    U1MODEbits.BRGH = 0;                   /* Режим высокой скорости передачи выключен */
    U1BRG = PBCLK2_ / (U5_speed * 16) - 1; // Установить скорость передачи данных
    IFS3bits.U1TXIF = 0;                   /* Сбросить флаг прерывания передачи данных */
    IPC28bits.U1TXIP = 2;                  /* Установить приоритет прерывания передачи данных */
    IPC28bits.U1TXIS = 0;                  /* Установить подприоритет прерывания передачи данных */
    IEC3bits.U1TXIE = 0;                   /* Разрешить прерывания при передаче данных */
    IFS3bits.U1RXIF = 0;                   /* Сбросить флаг прерывания приема данных */
    IPC28bits.U1RXIP = 2;                  /* Установить приоритет прерывания приема данных */
    IPC28bits.U1RXIS = 0;                  /* Установить подприоритет прерывания приема данных */
    IEC3bits.U1RXIE = 1;                   /* Разрешить прерывания при приеме данных */
    U1STAbits.UTXEN = 1;                   /* Включить передатчик UART1 */
    U1STAbits.URXEN = 1;                   /* Включить приемник UART1 */
    U1STAbits.UTXISEL = 0b10;              /* Установить условие генерации прерывания при передаче данных (пустой буфер) */
    U1MODEbits.ON = 1;                     /* Включить модуль UART1 */
}
/* Эта функция инициализирует модуль UART2 с заданными параметрами, включает передающий и приемный режимы,
а также включает прерывания для передачи и приема данных. */

void UART1_init(unsigned int speed)
{
    U1MODE = 0x0000; // Отключение передатчика UART1

    URXISEL1 = 0b00; // Флаг прерывания устанавливается при приеме символа
    //	UTXISEL_1=0;				// Флаг прерывания устанавливается при передаче символа и буфер пуст
    PDSEL1 = 0b00; // Данные 8 бит, без контроля четности
    STSEL1 = 0;    // Один стоповый бит

    IEC3bits.U1RXIE = 0; // Отключение прерывания приемника UART1
    IEC3bits.U1TXIE = 0; // Отключение прерывания передатчика UART1

    switch (speed)
    {
    case 1:
    {
        U1BRG = ((Fcy) / 16) / 1200 - 1;            // Установка скорости передачи 1200 бод
        frame_delay = Fcy / 8 / 1200 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }
    case 2:
    {
        U1BRG = ((Fcy) / 16) / 2400 - 1;            // Установка скорости передачи 2400 бод
        frame_delay = Fcy / 8 / 2400 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }

    case 3:
    {
        U1BRG = ((Fcy) / 16) / 4800 - 1;            // Установка скорости передачи 4800 бод
        frame_delay = Fcy / 8 / 4800 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }

    case 4:
    {
        U1BRG = ((Fcy) / 16) / 9600 - 1;            // Установка скорости передачи 9600 бод
        frame_delay = Fcy / 8 / 9600 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }

    case 5:
    {
        U1BRG = ((Fcy) / 16) / 19200 - 1;            // Установка скорости передачи 19200 бод
        frame_delay = Fcy / 8 / 19200 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }

    case 6:
    {
        U1BRG = ((Fcy) / 16) / 38400 - 1;            // Установка скорости передачи 38400 бод
        frame_delay = Fcy / 8 / 38400 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }

    case 7:
    {
        U1BRG = ((Fcy) / 16) / 57600 - 1;            // Установка скорости передачи 57600 бод
        frame_delay = Fcy / 8 / 57600 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }

    case 8:
    {
        U1BRG = ((Fcy) / 16) / 115200 - 1;            // Установка скорости передачи 115200 бод
        frame_delay = Fcy / 8 / 115200 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }

    default:
    {
        U1BRG = ((Fcy) / 16) / 38400 - 1;            // Установка скорости передачи 38400 бод по умолчанию
        frame_delay = Fcy / 8 / 38400 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }
    }
    UARTEN1 = 1;         // Включение UART1
    UTXEN1 = 1;          // Включение передатчика UART1
    IEC3bits.U1RXIE = 0; // Отключение прерывания приемника UART1
    ENAB_RX1;            // Включение приемника UART1
}
/* Выбранный фрагмент кода инициализирует модуль UART1 с заданными параметрами, включает передающий и приемный режимы, а
также включает прерывания для передачи и приема данных. */

void UART2_init(unsigned int speed)
{
    U2MODE = 0x0000; // Отключение передатчика UART2

    URXISEL2 = 0b00; // Флаг прерывания устанавливается при приеме символа
    //	UTXISEL_1=0;				// Флаг прерывания устанавливается при передаче символа и буфер пуст
    PDSEL2 = 0b00; // Данные 8 бит, без контроля четности
    STSEL2 = 0;    // Один стоповый бит

    IEC4bits.U2RXIE = 0; // Отключение прерывания приемника UART2
    IEC4bits.U2TXIE = 0; // Отключение прерывания передатчика UART2

    switch (speed)
    {
    case 1:
    {
        U2BRG = ((Fcy) / 16) / 1200 - 1;            // Установка скорости передачи 1200 бод
        frame_delay = Fcy / 8 / 1200 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }
    case 2:
    {
        U2BRG = ((Fcy) / 16) / 2400 - 1;            // Установка скорости передачи 2400 бод
        frame_delay = Fcy / 8 / 2400 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }

    case 3:
    {
        U2BRG = ((Fcy) / 16) / 4800 - 1;            // Установка скорости передачи 4800 бод
        frame_delay = Fcy / 8 / 4800 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }

    case 4:
    {
        U2BRG = ((Fcy) / 16) / 9600 - 1;            // Установка скорости передачи 9600 бод
        frame_delay = Fcy / 8 / 9600 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }

    case 5:
    {
        U2BRG = ((Fcy) / 16) / 19200 - 1;            // Установка скорости передачи 19200 бод
        frame_delay = Fcy / 8 / 19200 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }

    case 6:
    {
        U2BRG = ((Fcy) / 16) / 38400 - 1;            // Установка скорости передачи 38400 бод
        frame_delay = Fcy / 8 / 38400 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }

    case 7:
    {
        U2BRG = ((Fcy) / 16) / 57600 - 1;            // Установка скорости передачи 57600 бод
        frame_delay = Fcy / 8 / 57600 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }

    case 8:
    {
        U2BRG = ((Fcy) / 16) / 115200 - 1;            // Установка скорости передачи 115200 бод
        frame_delay = Fcy / 8 / 115200 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }

    default:
    {
        U2BRG = ((Fcy) / 16) / 38400 - 1;            // Установка скорости передачи 38400 бод по умолчанию
        frame_delay = Fcy / 8 / 38400 * rx_timeout1; // Рассчет задержки между фреймами
        break;
    }
    }
    UARTEN2 = 1;         // Включение UART2
    UTXEN2 = 1;          // Включение передатчика UART2
    IEC4bits.U2RXIE = 0; // Отключ
    ENAB_RX2;            // Включение приемника UART2
}
/* Выбранный фрагмент кода инициализирует модуль UART1 с заданными параметрами, включает передающий и приемный режимы, а
также включает прерывания для передачи и приема данных. */

void UART4_init(unsigned int speed)
{
    U4MODE = 0x0000; // Отключение передатчика UART2

    URXISEL4 = 0b00; // Флаг прерывания устанавливается при приеме символа
    //	UTXISEL_1=0;				// Флаг прерывания устанавливается при передаче символа, и буфер пуст
    PDSEL4 = 0b00; // Данные 8 бит, без проверки четности
    STSEL4 = 0;    // 1 стоп-бит

    IEC5bits.U4RXIE = 0; // Запрещение прерывания при приеме
    IEC5bits.U4TXIE = 0; // Запрещение прерывания при передаче

    switch (speed)
    {
    case 1:
    {
        U4BRG = ((Fcy) / 16) / 1200 - 1;            // Расчет скорости передачи для 1200 бод
        frame_delay = Fcy / 8 / 1200 * rx_timeout1; // Вычисление времени межкадровой паузы для 1200 бод
        break;
    }
    case 2:
    {
        U4BRG = ((Fcy) / 16) / 2400 - 1;            // Расчет скорости передачи для 2400 бод
        frame_delay = Fcy / 8 / 2400 * rx_timeout1; // Вычисление времени межкадровой паузы для 2400 бод
        break;
    }

    case 3:
    {
        U4BRG = ((Fcy) / 16) / 4800 - 1;            // Расчет скорости передачи для 4800 бод
        frame_delay = Fcy / 8 / 4800 * rx_timeout1; // Вычисление времени межкадровой паузы для 4800 бод
        break;
    }

    case 4:
    {
        U4BRG = ((Fcy) / 16) / 9600 - 1;            // Расчет скорости передачи для 9600 бод
        frame_delay = Fcy / 8 / 9600 * rx_timeout1; // Вычисление времени межкадровой паузы для 9600 бод
        break;
    }

    case 5:
    {
        U4BRG = ((Fcy) / 16) / 19200 - 1;            // Расчет скорости передачи для 19200 бод
        frame_delay = Fcy / 8 / 19200 * rx_timeout1; // Вычисление времени межкадровой паузы для 19200 бод
        break;
    }

    case 6:
    {
        U4BRG = ((Fcy) / 16) / 38400 - 1;            // Расчет скорости передачи для 38400 бод
        frame_delay = Fcy / 8 / 38400 * rx_timeout1; // Вычисление времени межкадровой паузы для 38400 бод
        break;
    }

    case 7:
    {
        U4BRG = ((Fcy) / 16) / 57600 - 1;            // Расчет скорости передачи для 57600 бод
        frame_delay = Fcy / 8 / 57600 * rx_timeout1; // Вычисление времени межкадровой паузы для 57600 бод
        break;
    }

    case 8:
    {
        U4BRG = ((Fcy) / 16) / 115200 - 1;            // Расчет скорости передачи для 115200 бод
        frame_delay = Fcy / 8 / 115200 * rx_timeout1; // Вычисление времени межкадровой паузы для 115200 бод
        break;
    }

    default:
    {
        U4BRG = ((Fcy) / 16) / 38400 - 1;            // Расчет скорости передачи для 38400 бод по умолчанию
        frame_delay = Fcy / 8 / 38400 * rx_timeout1; // Вычисление времени межкадровой паузы для 38400 бод по умолчанию
        break;
    }
    }
    UARTEN4 = 1;         // Включение UART1
    UTXEN4 = 1;          // Включение передатчика UART4
    IEC5bits.U4RXIE = 0; // Запрещение прерывания при приеме
    ENAB_RX4;            // Включение приемника UART4
}

void UART5_init(unsigned int speed)
{
    U5MODE = 0x0000; // Отключение передатчика UART5

    URXISEL5 = 0b00; // Установка флага прерывания при приеме символа
    // UTXISEL_1=0; // Флаг прерывания устанавливается при передаче символа и буфер пустой (не используется в данном коде)
    PDSEL5 = 0b00; // Установка формата передачи: 8 бит данных, без контроля четности
    STSEL5 = 0;    // Установка количества стоповых битов: 1 стоповый бит

    IEC5bits.U5RXIE = 0; // Запрещение прерывания при приеме
    IEC5bits.U5TXIE = 0; // Запрещение прерывания при передаче

    switch (speed)
    {
    case 1:
    {
        U5BRG = ((Fcy) / 16) / 1200 - 1;            // Установка значения делителя для скорости 1200 бод
        frame_delay = Fcy / 8 / 1200 * rx_timeout1; // Вычисление задержки кадра для скорости 1200 бод
        break;
    }
    case 2:
    {
        U5BRG = ((Fcy) / 16) / 2400 - 1;            // Установка значения делителя для скорости 2400 бод
        frame_delay = Fcy / 8 / 2400 * rx_timeout1; // Вычисление задержки кадра для скорости 2400 бод
        break;
    }

    case 3:
    {
        U5BRG = ((Fcy) / 16) / 4800 - 1;            // Установка значения делителя для скорости 4800 бод
        frame_delay = Fcy / 8 / 4800 * rx_timeout1; // Вычисление задержки кадра для скорости 4800 бод
        break;
    }

    case 4:
    {
        U5BRG = ((Fcy) / 16) / 9600 - 1;            // Установка значения делителя для скорости 9600 бод
        frame_delay = Fcy / 8 / 9600 * rx_timeout1; // Вычисление задержки кадра для скорости 9600 бод
        break;
    }

    case 5:
    {
        U5BRG = ((Fcy) / 16) / 19200 - 1;            // Установка значения делителя для скорости 19200 бод
        frame_delay = Fcy / 8 / 19200 * rx_timeout1; // Вычисление задержки кадра для скорости 19200 бод
        break;
    }

    case 6:
    {
        U5BRG = ((Fcy) / 16) / 38400 - 1;            // Установка значения делителя для скорости 38400 бод
        frame_delay = Fcy / 8 / 38400 * rx_timeout1; // Вычисление задержки кадра для скорости 38400 бод
        break;
    }

    case 7:
    {
        U5BRG = ((Fcy) / 16) / 57600 - 1;            // Установка значения делителя для скорости 57600 бод
        frame_delay = Fcy / 8 / 57600 * rx_timeout1; // Вычисление задержки кадра для скорости 57600 бод
        break;
    }

    case 8:
    {
        U5BRG = ((Fcy) / 16) / 115200 - 1;            // Установка значения делителя для скорости 115200 бод
        frame_delay = Fcy / 8 / 115200 * rx_timeout1; // Вычисление задержки кадра для скорости 115200 бод
        break;
    }

    default:
    {
        U5BRG = ((Fcy) / 16) / 38400 - 1;            // Установка значения делителя для скорости 38400 бод по уммолчанию
        frame_delay = Fcy / 8 / 38400 * rx_timeout1; // Вычисление задержки кадра для скорости 38400 бод
        break;
    }
    }
    UARTEN5 = 1;         // Включение UART5
    UTXEN5 = 1;          // Разрешение передачи через UART5
    IEC5bits.U5RXIE = 0; // Запрещение прерывания при приеме через UART5
    ENAB_RX5;            // Включение приемника UART5
}

/* Функции типа UARTx_init служат для инициализации модулей UART (Universal Asynchronous Receiver/Transmitter) с определенной скоростью передачи данных.
Каждая функция принимает один аргумент speed, который определяет скорость передачи данных в бодах.
Внутри функции происходит настройка параметров UART, таких как режим передачи данных (например, 8-битные данные без проверки на четность),
количество стоп-битов, выбор прерывания при приеме данных, и другие параметры.
После этого происходит выбор скорости передачи данных. В зависимости от выбранной скорости, вычисляется значение регистра BRG,
который определяет делитель частоты для достижения желаемой скорости передачи.
Наконец, включается модуль UART, разрешается передача данных и прием через UART, и, при необходимости, включается прерывание при приеме данных.
Таким образом, функции UARTx_init позволяют настроить и включить модуль UART для работы с определенной скоростью передачи данных. */

void spi5_init(void)
{
    unsigned int t_brg;     // Переменная для хранения значения BRG (Baud Rate Generator)
    unsigned int baudHigh;  // Переменная для хранения вычисленной высокой скорости передачи данных
    unsigned int baudLow;   // Переменная для хранения вычисленной низкой скорости передачи данных
    unsigned int errorHigh; // Переменная для хранения ошибки высокой скорости передачи данных
    unsigned int errorLow;  // Переменная для хранения ошибки низкой скорости передачи данных
    unsigned int baudRate;  // Желаемая скорость передачи данных

    baudRate = 8294400; // Установка желаемой скорости передачи данных

    SPI5CONbits.ON = 0;                       // Выключение модуля SPI
    SPI5CONbits.MSTEN = 1;                    // Установка в режим мастера
    SPI5CONbits.MSSEN = 0;                    // Отключение SS (Slave Select)
    SPI5CONbits.SIDL = 0;                     // Продолжение работы в режиме Idle
    SPI5CONbits.CKP = 0;                      // Выбор фронта для синхронизации (Idle to Active)
    SPI5CONbits.CKE = 1;                      // Фронт данных: прочтение на фронте
    SPI5CONbits.SMP = 0;                      // Программное управление выбором фазы
    SPI5CONbits.MODE16 = 0;                   // Режим 16 бит выключен
    SPI5CONbits.MODE32 = 0;                   // Режим 32 бит выключен
    SPI5CONbits.FRMEN = 0;                    // Режим кадра выключен
    SPI5CON2bits.AUDEN = 0;                   // Аудио режим выключен
    SPI5CONbits.ENHBUF = 1;                   // Расширенный буфер включен
    t_brg = (((PBCLK2_ / baudRate) / 2) - 1); // Рассчитываем BRG
    baudHigh = PBCLK2_ / (2 * (t_brg + 1));   // Рассчитываем высокую скорость передачи данных
    baudLow = PBCLK2_ / (2 * (t_brg + 2));    // Рассчитываем низкую скорость передачи данных
    errorHigh = baudHigh - baudRate;          // Вычисляем ошибку для высокой скорости
    errorLow = baudRate - baudLow;            // Вычисляем ошибку для низкой скорости
    if (errorHigh > errorLow)                 // Сравниваем ошибки
    {
        t_brg++; // Корректируем BRG, если ошибка высокой скорости больше
    }
    SPI5BRG = t_brg;    // Устанавливаем BRG
    SPI5CONbits.ON = 1; // Включаем модуль SPI
}
/* Эта функция spi5_init() используется для инициализации модуля SPI5 микроконтроллера. В ней производится настройка
различных параметров передачи данных, таких как режим работы (мастер или рабочий), выбор фронта для синхронизации, режим
работы буфера данных, скорость передачи данных (через BRG), а также включение самого модуля SPI5. */

void InitializeSystem(void)
{
    // PIC32MZ CPU Speed Optimizations (Cache/Wait States/Peripheral Bus Clks)
    // On reset, I+D cache is enabled for max performace setting (write-back with write allocation)
    // No wait setting required for main data RAM

    // Prefetch-cache: Enable prefetch for PFM (any PFM instructions or data)
    PRECONbits.PREFEN = 3; // Включение предварительной выборки для PFM (загрузка любых инструкций или данных PFM в кэш)
    // Flash PM Wait States: MZ Flash runs at 2 wait states @ 200 MHz
    PRECONbits.PFMWS = 2; // Установка времени ожидания для Flash PM (что-то связанное с временем ожидания)
    // PBClk3 set to 8 MHz (assumes SYSCLK = 200 MHz via configuration bits)
    // Unlock Sequence
    /* процесс разблокировки важных регистров */
    SYSKEY = 0xAA996655;
    SYSKEY = 0x556699AA;
    // Modify PB3DIV
    PB2DIVbits.PBDIV = 3; // Установка делителя для PBCLK (частота SYSCLK/8 = 24883200 Гц)
    CFGCONbits.OCACLK = 1;
    PB3DIVbits.PBDIV = 3; // Установка делителя для PBCLK3 (частота SYSCLK/25 = 8 МГц)
    // Lock sequence
    SYSKEY = 0x33333333;

    port_init();   // Инициализация портов
    spi5_init();   // Инициализация SPI5
    help_load = 1; // Загрузка справочной информации
    conf_read();   // Чтение конфигурации

    tmr_1_init(100, 0, 0); // Инициализация таймера 1
    tmr_2_init(100, 0, 0); // Инициализация таймера 2
    // tmr_4_init();
    tmr_5_init(100, 0, 0);   // Инициализация таймера 5
    tmr_6_init(100, 0, 0);   // Инициализация таймера 6
    tmr_7_init(100, 0, 0);   // Инициализация таймера 7
    tmr_9_init(65000, 1, 1); // Инициализация таймера 9
    OC3_init();              // Инициализация выхода сравнения OC3
    uart5_init();            // Инициализация UART5
    uart4_init();            // Инициализация UART4
    uart3_init();            // Инициализация UART3
    uart2_init();            // Инициализация UART2
    uart1_init();            // Инициализация UART1
    DMA5_init();             // Инициализация DMA5
    DMA4_init();             // Инициализация DMA4
    DMA3_init();             // Инициализация DMA3
    DMA2_init();             // Инициализация DMA2
    DMA1_init();             // Инициализация DMA1

    /* Assign PIC32MZ shadow register sets to specific CPU IPLs */
    PRISS = 0x76543210;

    /* Set Interrupt Controller for multi-vector mode */
    INTCONSET = _INTCON_MVEC_MASK; // Установка контроллера прерываний в многовекторный режим

    /* Enable Interrupt Exceptions */
    // Установите бит IE CP0 status высоко, чтобы глобально включить прерывания
    __builtin_enable_interrupts();

    /* Enable the peripheral */
    /* Включить периферию */
    T2CONbits.TON = 1; // Включение таймера 2
    T1CONbits.TON = 1; // Включение таймера 1
    T4CONbits.ON = 1;  // Включение таймера 4
    T5CONbits.ON = 1;  // Включение таймера 5
    T2CONbits.ON = 1;  // Включение таймера 2
    OC3CONbits.ON = 1; // Включение OC3
    //    ADCCON3bits.GSWTRG = 1;
}